{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{406:function(n,e,a){\"use strict\";a.r(e);var t=a(56),r=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"java\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#java\"}},[n._v(\"#\")]),n._v(\" Java\")]),n._v(\" \"),a(\"p\",[n._v(\"1应用程序=算法+数据结构（线性 队列 栈\\n树性 二叉树）\\n引用数据类型 类(String) 接口数组\\nScanner scan = new Scanner(System.in);\")]),n._v(\" \"),a(\"p\",[n._v(\"switch:byte,short,char,int,枚举,String\\nfor外层控制行数，内层控制列数\\n数组元素默认初始化赋值\\n堆：new出来的结构 数组 对象\\n栈：局部变量（方法中的包括main）\\n数组重新new，堆空间重新开辟\\n二维数组外层元素初始化值为地址值，内层为实际值\\n面向对象的两个要素 类 对象(实例)\\nmain方法中定义的变量都是局部变量 Person p =new Perso();\\n对象实例new Person\\n[a,b): (b-a+1)+a\\n编译完程序，生成字节码文件,使用jvm中类的加载器和解释器对生成的字节码文件解释运行，才将字节码文件加载到内存中，涉及内存解析（即堆栈）\\n涉及到java语言与前端html,后端数据库交互时,前后端的结构在java层面交互，都体现为类对象\\n封装性的体现：私有属性，私有方法，单例模式等等\\nthis理解为当前对象或当前正在创建的对象(构造器中)\\n对象的多态：编译看左，运行看右，new谁用谁（只适用方法,不适用属性,属性全看左） Person p =new Man()和数据库连接     节省代码,灵活\\nJava中的绑定:绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来(这个方法被哪个类调用).对Java来说,\")]),n._v(\" \"),a(\"p\",[n._v(\"分为静态绑定和动态绑定.\")]),n._v(\" \"),a(\"p\",[n._v(\"静态调用:在程序执行前方法已经被绑定,也就是在编译期方法明确知道被哪个类调用.java当中的方法只有final，static，private和构造方法是前期绑定的。\")]),n._v(\" \"),a(\"p\",[n._v(\"动态调用:在运行时根据具体对象的类型进行绑定(只有运行时才知道方法被哪个类调用).在java中，几乎所有的方法都是后期绑定的。\")]),n._v(\" \"),a(\"p\",[n._v(\"总结:编译期可以编写一些指令,可以在运行前就知道结果.\\n重载静态绑定(编译期认定为不同方法，不表现为多态)，重写动态绑定(表现为多态)\\nStirng,Data,File,包装类等都重写了equals()，比较的是内容\\n向下转型需要new其子类 Person p =new Person(),Man m =（Man）p;  错误\\ninstanceof看其本质new的是什么，和它所属的类型  Person p=new Man();  p instanceof Person,Man\\nInteger中有 IntegerCache\\n抽象类,接口的使用肯定体现了多态性,因为不能实例化\\n数组也可以看成一个特殊的类\\n非静态变量也叫实例变量\\n静态变量随着类的加载而加载,类只会加载一次，静态变量在内存中也只有一份\\n成员变量叫属性，属性不能操作\\n类加载而加载(static,)，普通代码块,构造器，随着对象的创建加载\\n继承是一个“是不是”的关系，接口实现则是“能不能”的关系\\n接口和接口可以多继承\\n驱动是接口的实现类\\njava8中为接口添加静态方法和默认方法，且实现类不能调用其静态方法\\n数据库连接,输入输出流，网络编程socket，jvm不能自动回收,故手动释放需要放在finally中\\n子类重写的方法抛出的一场类型不大于父类被重写的方法抛出的异常类型\")]),n._v(\" \"),a(\"p\",[n._v(\"8多线程\\n每个线程都有栈和程序计数器，多个线程共享方法区和堆\\n并行多个cpu同时执行多个任务,并发一个cpu同时执行多个任务\\n创建多线程: 1继承Thread  2实现Runnable(优先,没有单继承局限,可以处理共享数据)\\n实例化线程时，如果有传入target,则调用Runnable中的run(),线程.start()执行的是run()方法\\n同步锁，谁进去谁锁(进去的对象没结束被锁住)\\n同步锁，多个线程必须共用同一把锁(1继承thread 代码块static  obj/xx.class  方法static   2implements Runnable  代码块this    方法)\\n静态方法只能类调用静态方法和静态属性，非静态的方法属性只能有对象调用\\n同步方法任然有同步监视器，不需要显式声明，非静态的同步方法，监视器是this,静态的同步方法,监视器是当前类本身\\n同一个类中，不同线程synchronized不同代码块传入同一对象，执行时有可能有死锁问题\\n使用顺序：lock,同步代码块,同步方法\\nlock和synchronized都可以解决线程安全问题，但lock需要手动释放\\n交替使用wait(),notify(),notifyAll(),且这三个都必须使用在同步代码块和同步方法中，且这三个方法的调用者必须时同步代码块和同步方法中的同步监视器,这三个方法都是定义在object类中\\nsleep()和wait()  相同: 都让线程阻塞  不同:1 Thread中的sleep()  Object类中的wait  2sleep()随处可用,wait()需在同步代码块或同步方法  3若用在同步代码块或同步方法,sleep()不会释放锁,wait()会释放锁\\nJDK5.0新增多线程: 1implements callable   2线程池\")]),n._v(\" \"),a(\"p\",[n._v('9java常用类\\nString\\n类代表不可变的字符序列(对字符串重赋值,修改,replace()都不会对原有数组改变)，内部定义了final char [],数组一定义，就永远不会变,类实现了Serializable接口和Comparable接口\\nString s5=s1+\"ss\",这个s5不是在常量池，而是在堆中开辟了一个空间，再指向常量池的中的字符串，故s5的地址值是堆中的地址,若s1为final常量，因为常量+常量，则拼接在常量池中完成，\\nString.intern()会将常量池中的地址返回\\nString与char[]:  string.toCharArray()   new String(arr)\\nString与Integer:  Integer.pareseInt(str)   String.valueOf(num)\\nString与byte[]:  str.getBytes()     new String(byte,\"\")字符串不填默认UTF-8\\nStringBuffer可变的字符序列，线程安全，底层创建了一个长度为16的数组,默认情况下,扩容为原来容量的2倍+2,同时将原有数组中的元素赋值到新数组\\nStringBuilder可变的字符序列，线程不安全,效率高\\nSystem类 时间戳\\njdk8之前的日期时间API\\n（父）java.util.Date()和（子）java.sql.Date(数据库变量)\\nutil.Date 创建对象 new Date()  和 new Date(毫秒)\\njava.sql.Date b =new java.sql.Date(date.getTime());utilDate转换成sqlDate\\nString,包装类实现了comparable自然排序,重写了compareTo()方法,进行排序,comparable在类中进行实现\\n接口comparator实现定制排序,类似临时定制 Array.sort(arr,new comparator(){});\\nSimpleDateFormat(1格式化new SimpleDateFormat().format(date) 2解析)\\n编码：字符串到字节,解析:字符串到日期\\nSimpleDateFormat s =new SimpleDateForma(\"yyyy-MM-dd\"); String e =s.formate(date); Date d=s.parse(\"2020-02-18\");\\nDateFormatter同上作用\\nCalendar日历类(抽象)\\n实例化 1创建其子类GregorianCalendar的对象 2Calendar.getInstance()\\nJDK8新时间日期API\\nLocalDate,LocalTime,LocalDateTime\\n当需要定义一组常量，则使用枚举类，枚举类默认继承于java.lang.Enum类\\n获取注解信息，通过反射来获取调用.')]),n._v(\" \"),a(\"p\",[n._v(\"11Java集合\\ncollection.contains(s),调用s中得equals方法与集合中得对象进行比较，如果s没有重写equals()方法,则调用Object类的，remove同理\\njava.utils.Arrays用来操作数组的类\\nCollection:\\nCollection接口继承了iterable接口 Iterator iterator=new ArrayList().iterator();或者使用foreach遍历,map不可用iterator，除非key或value转换\\nList(存储自定义类需重写equals()):\\nArrayList作为List接口的主要实现类，线程不安全，底层使用Object[] elementData存储,jdk7new ArrayList()就创建了长度是10的数组,容量不够默认情况下,扩容为原来容量的1.5倍,同时需要将原有数组的中的数据复制到新的数组中,故建议开发中使用带参的构造器;jdk8中等到集合调用add方法才创建长度为10的数组\\nLinkedList对于频繁的插入，删除操作，效率比ArrayList高，底层使用双向链表存储,内部声明了node类型的first和last属性\\nVector:作为LIst的古老实现类，线程安全,效率低,底层使用Object[],默认扩容为原来的2倍\\nSet:\\nSet存储无序（没有索引)，不可重复的数据(添加数据所在类一定要重写两个方法,对象中用作equals()方法比较的Field，都应该用来计算hashCode(),如果没有重写，则按Object类中的hashCode()和equals())\\nHashSet(数组+链表)无序(存储的数组在底层数组中不是按索引的顺序，而是根据数据的哈希值)，不可重复(先算元素哈希值,再根据算法算出HasSet底层数组的存放位置,判断是否有元素,再根据哈希值不同则添加到链表,相同再根据equals判断，flase则加入到链表中(七上八下),不能返回true)\\nLinkedSet是HashSet的子类,\\nLinkedHashSet底层以双向链表的方式存储到数组中\\nTreeSet中添加的数据是相同类的对象,可以不重写hashCode()和equals(),因为排序是根据自然排序(compareTo())或定制排序(Comparator),底层是红黑树\\nMap(key:无序不可重复,使用Set存储所有的Key,key所在的类要重写equals和hashcode(),value:无序可重复,使用collection存储所有的value，value所在的类要重写equals();key,value是以一个Entry对象的方式存储,entry无序不可重复,使用Set存储所有的entry;  key,value遍历  entry遍历)\\nHashMap(线程不安全,效率高，存储null的key和value，可以转换为线程安全)\\n底层实现原理(Jdk7:实例化后创建一个长度为16的Entry[] table,调用key1所在的类hashCode()计算key1哈希值,经过算法,得到Entry在数组中的位置,该位置空，则添加,非空，比较key1的哈希值,不同以链表方式添加,相同则比较equals()，返回false添加,返回true，使用value1替代原来的value；     JDk8与Jdk7的不同,底层没有创建一个16的Entry数组,而是Node[],首次调用put()方法时,才创建长度16的数组,jdk7底层的结构为数组+链表,jdk8中底层结构数组+链表+红黑树,当数组的某一个索引位置的元素以链表形式存在的数据个数>8且当且数组的长度>64时,此时此索引位置上的所有数据改为使用红黑树存储)\\nLinkedHashMap(可以按照添加的顺序实现遍历,在原HashMap底层结构基础上，添加了一对指针)\\nHashtable(线程安全,效率低,不能存储null的key和value)\\nProperties(key和value都时String类型)\"),a(\"br\"),n._v(\"\\nTreeMap (保证按照添加的key-value对进行排序可以不重写hashCode()和equals()，需要有自然排序或定制排序)\\nCollections是一个操作Set，List,和Map等集合的工具类,方法：reverse(List)反转,shuffle(List)随机排序,sort(List)根据元素的自然顺序对指定list集合元素按升序排序,sort(List,Comparator)定制排序集合,swap(List，int,int)指定list集合中的i处元素和j出元素进行交换\")]),n._v(\" \"),a(\"p\",[n._v(\"ArrayList和HashMap都是线程不安全的,如果程序要求线程安全,我们可以将ArrayList,HashMap转换为线程安全,使用synchronizedList和synchronizedMap\\n12 泛型\\n如果子类在继承带泛型的父类时,指明了泛型类型,则实例化子类对象时,不需要再指明泛型\\n在类和接口声明的泛型中,静态方法中不能使用泛型,泛型方法中声明的泛型静态方法可以使用, T[] arr =new T [10]编译不通过,因为此时的T是变量\\n类A是类B的父类,G<A>和G<B>不是父子类,二者的共同父类是G<?>;A<G>和B<G>是父子类\\nList<?>可以赋对象，读数据,不能向内部添加数据,除了add(null)\")]),n._v(\" \"),a(\"p\",[n._v(\"13 IO流\\nFile类创建文件,当硬盘有时,创建File对象，各个属性会显式赋值,若没有,除了指定的目录和路径外,其他属性都是默认值\\n处理流作用于节点流的，提升效率  文件流属于节点流，缓冲流属于处理流，对象流是处理流\\n对象序列化ObjectOutputStream机制允许把内存中的java对象转换成二进制流,将其保存在硬盘上,反序列化则相反\\n序列化的好处可将任何实现了Serializable接口的对象转化成字节数据,使其在保存和输出可被还原\\n对象流不能序列化static和transient修饰的成员变量\\n自定义序列化类需要版本号,基本数据类型和String本身是已序列化的,如果有内部类，也需要序列化,\\nRandomAccessFile继承于Objectlei,即是输入流又是输出流,若文件存在，则会对内容覆盖\\n14 网络编程\\n网络编程的两个要素：IP和端口号(找主机,定应用),提供的网络通信协议(传数据)\\n端口号与IP地址的组合得出一个网络套接字Socket\\nTCP/IP模型 :1应用层(Http等)2传输层(TCP,UDP) 3网络层(IP) 4物理+数据链路层\\nIP分类：IPv4和IPv6; 万维网(公网)和局域网\\nInetAddress此时一个类就代表着一个具体的IP地址\\nInetAddress实例化: 1getByName() 2getLocalHost()\\n常用方法：getHostName()  getHostAddress()\\n网络通信协议 ：1TCP:可靠，大量,需释放连接,效率低\\n2UDP:不可靠，不需连接，数据包,速度快，无需释放\")]),n._v(\" \"),a(\"p\",[n._v(\"15反射机制\\njava反射机制在运行时才决定类的对象，是动态的关键;正常方式:引包,new对象,获取实例化对象; 反射方式:实例化对象,getClass()方法,得到包\\n反射和封装不矛盾\\njava.lang.Class类的解释:程序经过javac.exe后，生成一个或多个字节码文件,(类的加载过程)：接着使用java.exe对某个字节码文件解释运行,相当于将某个字节码文件加载到内存中，此过程就称为类的加载,加载到内存中的类,我们就称为运行时类，此运行时类,就作为Class的一个实例,即Class的实例就对应着一个运行时类,Class实例是获取,不是new,再由反射创建对应的运行时类的对象\\n类加载器作用是用来吧类装载进内存的\\n在javabean中要求提供一个显式public的空参构造器,原因是便于通过反射,创建运行时类的对象;便于子类继承此运行时类时,默认调用super()，保证父类有此构造器\\n实现动态代理的问题：1如何根据加载到内存中的被代理类,动态的创建一个代理类及其对象 2当通过代理类的对象调用方法时,如何动态的去调用被代理类中的同名方法\\n代理类是固定写法，被代理类和接口可以是任意，代理类没有在编译时显示定义,而是在运行时根据被代理类动态创建\\nLambda表达式的总结:1左边：lambda形参列表的参数类型可以省略(类型推断),如果lambda形参列表只有一个参数,其一对()也省略 2右边: lambda体因该使用一对{}包裹,如果lambda体只有一条执行语句(可能是return语句),可以省略这一对()和return关键字\\n16 java8新特性\\n如果一个接口中,只声明了一个抽象方法,则此接口就称为函数式接口\\nLambda表达式的本质是作为函数式接口的实例\\njava内置的4大核心函数式接口: 1消费型接口 Consumer<T>   void accept(T t)  2供给型接口 Supplier<T>   T get()   3函数型接口  Function<T,R>   R apply(T  t)  4断定型接口 Predicate<T>   boolean  test(T t)\\n方法引用的使用 ：当要传递给lambda体的操作,已经有实现的方法时,就可以使用方法引用，本质也是lambda表达式\\n方法引用的使用格式:  1对象 : : 非静态方法   2对象: : 静态方法  3类 ：：非静态方法\\n方法引用的使用要求：接口中的抽象方法的形参列表和返回值类型于方法引用的方法的形参列表和返回值类型相同(针对使用格式12)\\n构造器引用/数组引用:函数式接口的  抽象方法形参列表和构造器的形参列表一致,抽象方法的返回值类型即为构造器所属的类型\\nStream API主要用于java层面处理数据,如MongDB,Redis非关系型数据库\\nStream和Collection集合的区别: Collection时一种静态的内存数据结构,而Stream是有关计算的,前者主要是面向内存,存储在内存,后者主要是面向cpu,通过cpu实现计算\\nStream的操作:1Stream的实例化(a集合: list.stream()顺序流 list.parallelStream()并行流 b数组Arrays.stream() c本身 Stream.of()  d无限流) 2中间操作  3终止操作(执行终止后,才执行中间操作链,并产生结果)\\nOptional<T>类是一个容器类，可以保存类型T的值,代表这个值存在,或者仅仅保存null，表示值不存在,可以避免空指针异常.\")]),n._v(\" \"),a(\"p\",[n._v(\"b树和B+树区别：b树常用在文件系统的索引上，因为文件系统和数据库的索引都是存在硬盘上的,b树具有多路存储能力,可以每次加载b树的一个节点，然后一步步往下找;B+树在b树的基础上改造的,它的数据都在叶子节点,同时叶子节点之间还加了指针形成链表，如果查询多条数据,b+树由于所有数据都在叶子节点,不用跨层,同时由于有链表结构，只需找到首尾，就可以把数据取出来.\")]),n._v(\" \"),a(\"p\",[n._v(\"堆排序:堆排序（Heap-Sort）是堆排序的接口算法，Heap-Sort先调用Build-Max-Heap将数组改造为最大堆，然后将堆顶和堆底元素交换，之后将底部上升，最后重新调用Max-Heapify保持最大堆性质。由于堆顶元素必然是堆中最大的元素，所以一次操作之后，堆中存在的最大元素被分离出堆，重复n-1次之后，数组排列完毕。如果是从小到大排序，用大顶堆；从大到小排序，用小顶堆。流程如下：\")]),n._v(\" \"),a(\"p\",[n._v(\"lock和synchronized都可以解决线程安全问题，但lock需要手动释放\")]),n._v(\" \"),a(\"p\",[n._v(\"top命令常用来监控linux系统状况,能实时显示系统的中各个进程资源占用情况,\\ntop [-d number] | top [-bnp]\\n如何防止表单重复提交 重定向  防重令牌token\\nredis实现分布式锁\\nCAS和MVCC\\nspringaop和事务怎么用\\nthis.basemapper basemapper\")])])}),[],!1,null,null,null);e.default=r.exports}}]);","extractedComments":[]}