{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{405:function(v,_,a){\"use strict\";a.r(_);var t=a(56),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"jvm\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jvm\"}},[v._v(\"#\")]),v._v(\" JVM\")]),v._v(\" \"),a(\"p\",[v._v(\"程序-框架-API-JVM\")]),v._v(\" \"),a(\"p\",[v._v(\"JVM机构模型: Java编译器输入的指令流基本上是属于一种栈的指令集架构（移植性好），一种基于寄存器的指令集架构（性能好）。\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\JVM架构.PNG)\")]),v._v(\" \"),a(\"p\",[v._v(\"由于跨平台的设计，JAVA的指令都是根据栈来设计的\")]),v._v(\" \"),a(\"p\",[v._v(\"虚拟机的启动:JAva虚拟机的启动时通过引导类加载器创建一个初始类来完成的，这个类是由虚拟机的具体实现指定的\")]),v._v(\" \"),a(\"p\",[v._v(\"HotSpot VM一次编译，处处运行\")]),v._v(\" \"),a(\"h2\",{attrs:{id:\"二-类加载子系统\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二-类加载子系统\"}},[v._v(\"#\")]),v._v(\" 二 类加载子系统\")]),v._v(\" \"),a(\"h4\",{attrs:{id:\"内存结构概述\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#内存结构概述\"}},[v._v(\"#\")]),v._v(\" 内存结构概述\")]),v._v(\" \"),a(\"h4\",{attrs:{id:\"类加载器与类的加载过程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#类加载器与类的加载过程\"}},[v._v(\"#\")]),v._v(\" 类加载器与类的加载过程\")]),v._v(\" \"),a(\"p\",[v._v(\"classloader只负责class文件的加载，运行由executionengine决定\")]),v._v(\" \"),a(\"p\",[v._v(\"CLASS File被加载到JVM，称为DNA元数据模板，放在方法区，根据这个文件实例化出N个实例\")]),v._v(\" \"),a(\"p\",[v._v(\".class文件->JVM->最终成为元数据模板，需要运输工具(Class Loader)\")]),v._v(\" \"),a(\"h4\",{attrs:{id:\"类加载过程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#类加载过程\"}},[v._v(\"#\")]),v._v(\" 类加载过程\")]),v._v(\" \"),a(\"p\",[v._v(\"加载-》链接（验证，准备，解析）-》初始化\")]),v._v(\" \"),a(\"p\",[v._v(\"类的生命周期\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"加载（由类名取二进制流\\\\字节流静态结构变方法去区运行时结构\\\\内存中生成对象作为方法区这些数据的访问入口），可通过自定义类加载器重写loadClass()方法控制字节流的获取。注：数组类不需类加载器，直接由虚拟机创建。\")]),v._v(\" \"),a(\"li\",[v._v(\"链接\")])]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"验证：是否符合虚拟机要求（如专属工具解析class文件开头CA FE BA BE,能被java虚拟机识别的有效起始和其他验证）\")]),v._v(\" \"),a(\"li\",[v._v(\"准备：为类变量分配内设置初始值（零值）的阶段\")])]),v._v(\" \"),a(\"p\",[v._v(\"注：不包含final（常量）修饰的static，编译时就已赋值\\n3. 解析（常常量池内符号引用转换为直接引用（直接指向目标的指针或间接定位对象的句柄等）的过程））\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"初始化（执行类构造器<client>()方法(由静态类变量显示赋值代码和静态代码块组成，只执行一次)的过程 ）\")]),v._v(\" \"),a(\"li\",[v._v(\"卸载：类的Class对象被GC\")])]),v._v(\" \"),a(\"p\",[v._v(\"卸载同时满足要求：\")]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"类实例对象都被GC\")]),v._v(\" \"),a(\"li\",[v._v(\"该类没有其他地方被引用\")]),v._v(\" \"),a(\"li\",[v._v(\"类的类加载器实例已被GC\")])]),v._v(\" \"),a(\"p\",[v._v(\"注：JVM自带的类加载器加载的类不会被卸载，自带类加载器会加载JDK提供的类，所以类加载器实列不会被回收。\")]),v._v(\" \"),a(\"p\",[v._v(\"两个工具（一个将class文件转换为16进制表示，一个展示出class文件的全部结构）\")]),v._v(\" \"),a(\"p\",[v._v(\"3类加载器分类\")]),v._v(\" \"),a(\"p\",[v._v(\"引导类（bootstrap classloader，用来加载java核心类库，加载扩展类和应用程序类加载器）\")]),v._v(\" \"),a(\"p\",[v._v(\"自定义类（派生于抽象类classloader的类加载器））\")]),v._v(\" \"),a(\"p\",[v._v(\"4ClassLoader的使用说明\")]),v._v(\" \"),a(\"p\",[v._v(\"5双亲委派机制\")]),v._v(\" \"),a(\"p\",[v._v(\"6其他\")]),v._v(\" \"),a(\"h2\",{attrs:{id:\"内存区域\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#内存区域\"}},[v._v(\"#\")]),v._v(\" 内存区域\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"虚拟机自动内存管理机制下(内存控制圈交予虚拟机)，不需要为new操作写delete/free操作，不容易出现内存泄漏和内存溢出问题，若出现需要了解虚拟机如何使用内存才能排查错误。\")])]),v._v(\" \"),a(\"h4\",{attrs:{id:\"运行时数据区-虚拟机将管理的内存划分为不同的数据区域\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#运行时数据区-虚拟机将管理的内存划分为不同的数据区域\"}},[v._v(\"#\")]),v._v(\" 运行时数据区（虚拟机将管理的内存划分为不同的数据区域）\")]),v._v(\" \"),a(\"p\",[v._v(\"注：垃圾回收（堆，方法区），OOM（堆，方法区，虚拟机栈，本地方法栈）\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"共享\")])]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"堆（存放对象实例，几乎所有的对象实例以及数组都在这里分配内存）\\nGC堆分代Eden、Survivor、Old，JDK8后老年代被元空间取代（更好地回收内存，或者更快地分配内存）\")])]),v._v(\" \"),a(\"p\",[v._v(\"对象通常在Eden区分配，新生代垃圾回收后，存活则进入S0或S1，年龄+1，年龄默认15时晋升到老年代。\")]),v._v(\" \"),a(\"p\",[v._v(\"注：随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。\")]),v._v(\" \"),a(\"p\",[v._v(\"堆这里最容易出现的就是 OutOfMemoryError 错误，如：GC Overhead Limit Exceeded回收堆空间很少   Java heap space堆内存不足以创建对象\\n2. 方法区（存储类信息、常量、静态变量、即时编译器编译后的代码等数据）\\n注： 方法区和永久代的关系很像 Java 中接口和类的关系，永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。\")]),v._v(\" \"),a(\"p\",[v._v(\"替换原因：内存溢出几率变小。加载更多类信息。\")]),v._v(\" \"),a(\"p\",[v._v(\"运行时常量池（Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用））\\n常用参数（元空间）：-XX:MetaspaceSize=N   -XX:MaxMetaspaceSize=N\\n3. 直接内存（非运行时数据区）\\n注：NIO类，直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。避免了在 Java 堆和 Native 堆之间来回复制数据。\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"私有\")])]),v._v(\" \"),a(\"ol\",[a(\"li\",[v._v(\"程序计数器(改变计数器值来选取下一条执行的字节码指令。作用：代码流程控制；多线程时用于记录当前线程执行位置)\")]),v._v(\" \"),a(\"li\",[v._v(\"虚拟机栈（由一个个栈帧组成）\\n栈帧： 局部变量表（基本数据类型和对象引用（reference类型，可能指向对象起始地址或执行对象句柄））  操作数栈 动态链接 方法出口信息\")])]),v._v(\" \"),a(\"p\",[v._v(\"注： Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。\")]),v._v(\" \"),a(\"p\",[v._v(\"StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。\")]),v._v(\" \"),a(\"p\",[v._v(\"OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。\")]),v._v(\" \"),a(\"p\",[v._v(\"Java 栈可以类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。\\n3. 本地方法栈（为虚拟机使用到Native方法服务）\")]),v._v(\" \"),a(\"h5\",{attrs:{id:\"pc寄存器常见问题\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#pc寄存器常见问题\"}},[v._v(\"#\")]),v._v(\" PC寄存器常见问题\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"PC寄存器存储字节码指令地址作用\")]),v._v(\" \"),a(\"li\",[v._v(\"PC寄存器记录当前线程的执行地址：CPU运行时不断切换线程，切换回来需要知道当前线程从哪里开始执行\")])]),v._v(\" \"),a(\"p\",[v._v(\"CPU时间片轮转，众多线程在并发执行过程中像是多个线程在并行\")]),v._v(\" \"),a(\"p\",[v._v(\"并行比较的时串行，并行与并发\")]),v._v(\" \"),a(\"p\",[v._v(\"垃圾回收线程一条串行，多条垃圾回收线程(用户线程需停止)并行，多条垃圾回收线程（用户线程不停止执行）并发\")]),v._v(\" \"),a(\"h5\",{attrs:{id:\"虚拟机栈\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#虚拟机栈\"}},[v._v(\"#\")]),v._v(\" 虚拟机栈\")]),v._v(\" \"),a(\"p\",[v._v(\"栈是运行时的单位，堆是存储的单位\")]),v._v(\" \"),a(\"p\",[v._v(\"两种异常：\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"StackOverflowError(如死递归（指针，快排有可能出现）)\")]),v._v(\" \"),a(\"li\",[v._v(\"OutOfMemoryError\")])]),v._v(\" \"),a(\"p\",[v._v(\"设置大小 -Xss1024k为Linux的默认（Idea VMoptions中设置）\")]),v._v(\" \"),a(\"p\",[v._v(\"class文件没有解析为二进制流文件，解析后是结构+操作指令等\")]),v._v(\" \"),a(\"p\",[v._v(\"栈帧中的动态链接：每一个栈帧内部包含一个指向运行时常量池中，该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。Java源文件被编译到字节码文件中时，所有的变量和方法引用都为符号引用保存再CLASS文件常量池中。\")]),v._v(\" \"),a(\"p\",[v._v(\"拥有动态链接后即拥有方法的jie\")]),v._v(\" \"),a(\"p\",[v._v(\"常量池运行起来后会将方法引用等信息存放到方法区中的运行时常量池\")]),v._v(\" \"),a(\"p\",[v._v(\"为什么需要常量池，为了提供一些符号和常量，便于指令的识别\")]),v._v(\" \"),a(\"p\",[v._v(\"方法调用其他方法在执行时将间件引用转换为直接引用（编译期确定为静态绑定，运行期确定为动态绑定）\")]),v._v(\" \"),a(\"p\",[v._v(\"调用非虚方法即编译期就能确定的\")]),v._v(\" \"),a(\"p\",[v._v(\"Java是静态类型语言，即判断变量类型自身信息，而不是变量值\")]),v._v(\" \"),a(\"p\",[v._v(\"执行引擎-》本地方法接口（Native Method Interface）->本地方法库(Native Method Libraries)\")]),v._v(\" \"),a(\"p\",[v._v(\"本地方法接口：native方法（一个JAVA调用非Java代码的接口）如Object类中的get Class（）/Thread类的start0(),Java层面的线程实际都需要转换成操作系统的本地线程\")]),v._v(\" \"),a(\"p\",[v._v(\"一个进程对应一个JVM实例，一个JVM实例中有一个运行时数据区（一个方法区一个堆，多个线程（多个程序计数器，本地方法栈，虚拟机栈）），\")]),v._v(\" \"),a(\"p\",[v._v(\"运行内存为虚拟内存，固态是物理内存，映射表将物理内存中不连续的地址到虚拟内存中形成逻辑上连续的地址\")]),v._v(\" \"),a(\"p\",[v._v(\"JVM规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的\")]),v._v(\" \"),a(\"p\",[v._v(\"新生代中伊甸园区和srrvivor区自适应的内存分配策略是默认关闭的，8:1:1\")]),v._v(\" \"),a(\"p\",[v._v(\"伊甸园区满了被回收，survivor中有放对象的是跟着被回收的\")]),v._v(\" \"),a(\"p\",[v._v(\"垃圾回收总结：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集\")]),v._v(\" \"),a(\"p\",[v._v(\"TLAB(堆是共享的，访问需要加锁，new对象是件麻烦的事情，为了提高效率，所以创建了TLAB，这个区域是线程独占的，无需考虑并发的问题分配对象就先分配到TLAB区域，满了或对象过大，就分配到TLAB外，这就要求我们创建对象时尽量创建小对象，提高效率)\")]),v._v(\" \"),a(\"p\",[v._v(\"代码优化之同步省略：JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程。锁对象也叫同步监视器，是否只能被一个线程访问，若是，则取消同步，这个取消同步的过程就叫同步省略，也叫锁消除。\")]),v._v(\" \"),a(\"p\",[v._v(\"对象实例都是分配在堆上的，根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗，虽然经过逃逸分析可以做标量替换、栈上分析和锁消除，但逃逸分析自身也需要进行一系列复制分析，相对来说也是一个耗时的过程。\")]),v._v(\" \"),a(\"p\",[v._v(\"如何解决OOM\")]),v._v(\" \"),a(\"p\",[v._v(\"静态引用对应的对象实体始终都存在堆空间\")]),v._v(\" \"),a(\"p\",[v._v(\"直接内存是在Java堆外的，直接向系统申请的内存空间，来源于NIO，通过存在队中的DirectByteBuffer操作Native内存，通常，访问直接内存的速度优于Java堆，即读写性能高。Java的Nio库允许Java程序使用直接内存，用于数据缓冲区。\")]),v._v(\" \"),a(\"p\",[v._v(\"使用Nio时，操作系统划出的直接缓存可以被Java代码直接访问,只有一份，NIO适合对大文件的读写操纵。\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"执行引擎-既有编译器又有解释器\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#执行引擎-既有编译器又有解释器\"}},[v._v(\"#\")]),v._v(\" 执行引擎（既有编译器又有解释器）\")]),v._v(\" \"),a(\"p\",[v._v(\"没有执行引擎就没有谁能负责将字节码文件放到内存中，字节码文件中的字节码指令如何被JVM识别依赖于执行引擎\")]),v._v(\" \"),a(\"p\",[v._v(\"执行引擎的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。\")]),v._v(\" \"),a(\"p\",[v._v(\"JMM字节码经过Java虚拟机执行引擎中的JIT编译器最终变成机器指令（编译，全部编译为机器语言），当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行。（解释，逐行解释为机器语言）\")]),v._v(\" \"),a(\"p\",[v._v(\"执行引擎在去解释执行字节码文件让操作系统去执行的时候我们既可以使用解释器又可以使用编译器。（Java是半编译半解释语言的原因）\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\半编译半解释.PNG)\")]),v._v(\" \"),a(\"p\",[v._v(\"高级语言-》汇编-》机器指令-》CPU\")]),v._v(\" \"),a(\"p\",[v._v(\"基于解释器执行已经沦落为低效的代名词。编译器将整个函数体编译成机器码，每次函数执行时，只执行编译后的机器码即可，还可将机器码缓存，下次获取不用编译。\")]),v._v(\" \"),a(\"p\",[v._v(\"热点数据触发JIT编译，方法调用计数器用于统计方法被调用的次数，在server模式下时10000次（安装的JVM默认为server）。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那么这个方法的调用及数据就会被减少一般。总的来说，只要系统运行的时间足够长，绝大部分方法都会被编译成本地代码。\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"string不可变性\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#string不可变性\"}},[v._v(\"#\")]),v._v(\" String不可变性\")]),v._v(\" \"),a(\"p\",[v._v(\"jdK9中String再也不用char[]存储，改成了byte[]加上编码标记，节约了空间\")]),v._v(\" \"),a(\"p\",[v._v(\"String中的String pool是一个固定大小的Hashtable，在JDK6中默认值大小是1009，如果池中的String太多，会造成Hash冲突严重，导致链表太长，造成string.intern时性能下降\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[v._v(\"常量与常量之间的拼接结果在常量池中，原理是编译期优化\")])]),v._v(\" \"),a(\"li\",[a(\"p\",[v._v(\"常量与变量的拼接，只要拼接中有一个是变量，结果就在堆中，变量拼接的原理是StringBuilder（在JDK5.0之前使用的是Stringbuffer）\")])]),v._v(\" \"),a(\"li\",[a(\"p\",[v._v(\"intern()：判断字符串常量池中是否存在某个值，存在，返回常量池中的地址值，不存在，就在常量池中加载一份某个值，并返回\")])]),v._v(\" \"),a(\"li\",[a(\"p\",[v._v(\"针对final修饰类、方法、基本数据类型，引用数据类型的量的结构时，能使用上final尽量使用上\")]),v._v(\" \"),a(\"p\",[v._v(\"拼接操作与append()效率：\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"StringBuilder.append()只创建了一个StringBuilder对象，String做字符串拼接操作时，创建过多个StringBuilder和String对象\")]),v._v(\" \"),a(\"li\",[v._v(\"字符串拼接的方式，创建的对象过多，占用的内存太大\")])]),v._v(\" \"),a(\"p\",[v._v(\"改进：StringBuilder底层使用的是数组，默认长度为16，数组满后会进行扩容复 制的操作，如果在初始化时就指定了固定的长度，就可以提高效率\")]),v._v(\" \"),a(\"p\",[v._v(\"intern()的使用：如果不是用双引号声明的String对象，可以使用String提供的intern方法确认字符串是否存在， 存在则返回字符串常量池中的地址，若不存在会创建一个引用（该地址（不是堆中对象的地址）指指向堆中的对象，JDK8）放入串池，并返回串池中的引用地址。通过new StringBuilder（“xx”）.toString()并不会在字符串常量池中生成“xx，其转化为String对象的API是new String(value, 0, count)，不是new String (char[]);\")]),v._v(\" \"),a(\"p\",[v._v(\"JDK6/7/8在处理常量之间拼接的不同\")]),v._v(\" \"),a(\"p\",[v._v(\"如果s3.intern()作用成功，就在字符串常量池中生成”xx“，\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"jdk6创建了一个新的对象”xx“（串池中没有将对象复制一份，放入串池，并返回串池中的对象地址）\")]),v._v(\" \"),a(\"li\",[v._v('jdk7/8字符串常量池被移到堆中，堆中已经有对象\"XX\",不需要在字符串常量池中再新建（串池中没有，把对象的引用地址复制一份，放入串池，并返回串池中的引用 地址）')]),v._v(\" \"),a(\"li\",[v._v(\"s4使用其字符串，则说明s4使用的是s3常量池的地址，s3==s4\")]),v._v(\" \"),a(\"li\",[v._v(\"s.intern创建引用后，为什么s==”aa“\")])]),v._v(\" \"),a(\"p\",[v._v(\"G1垃圾回收器的去重操作（堆存活数据集合里面 string对象占了25%，重复String对象有13.5%，堆上重复的String对象应该是一种内存浪费）\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"垃圾回收\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#垃圾回收\"}},[v._v(\"#\")]),v._v(\" 垃圾回收\")]),v._v(\" \"),a(\"p\",[v._v(\"垃圾指运行程序中没有任何指针指向的对象\")]),v._v(\" \"),a(\"p\",[v._v(\"垃圾回收简介：\")]),v._v(\" \"),a(\"p\",[v._v(\"（1）标记\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"引用计数算法\")]),v._v(\" \"),a(\"li\",[v._v(\"可达性分析算法（收集的对象：虚拟机中引用的对象、本地方法栈内JNI引用的对象、方法区中类静态属性引用的对象、所有被同步锁synchronized持有的对象、Java虚拟机内部的引用）-》涉及重写finalize()，不可达的对象并非非死不可\")]),v._v(\" \"),a(\"li\",[v._v(\"MAT相较于Jvisualm查看GC root更方便，是一款内存分析器/性能分析工具\")])]),v._v(\" \"),a(\"p\",[v._v(\"（2）清除\")]),v._v(\" \"),a(\"p\",[v._v(\"新的垃圾回收器更关注低延迟\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"垃圾回收的相关概念\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#垃圾回收的相关概念\"}},[v._v(\"#\")]),v._v(\" 垃圾回收的相关概念\")]),v._v(\" \"),a(\"p\",[v._v(\"（1）\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"System.gc()可以主动调用GC（提醒虚拟机显式触发Full GC，且会先调用Minor GC?）\")]),v._v(\" \"),a(\"li\",[v._v(\"System.runFinalization(强制调用使用引用的对象的finalize方法 )\")])]),v._v(\" \"),a(\"p\",[v._v(\"（2）内存溢出与内存泄漏\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"泄漏：单例模式（在单例模式中，如果持有对外部对象的引用，那么这个外部对象就不能被回收）/资源未close(数据库，socket,io)\")])]),v._v(\" \"),a(\"p\",[v._v(\"（3）stw事件理解（GC事件发生时，应用程序会停顿）\")]),v._v(\" \"),a(\"p\",[v._v(\"(4)垃圾回收的并发与并行\")]),v._v(\" \"),a(\"p\",[v._v(\"（5）安全点(程序不是任何时候都能执行GC)与安全区域(在区域内线程sleep唤醒后需完成GC才能离开)\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的safepoint\")])]),v._v(\" \"),a(\"p\",[v._v(\"（6）引用类型（强引：不回收/软引：内存不足即回收/弱引：发现即回收/虚引：对象回收跟踪）\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"强引用时造成Java内存泄漏的主要原因之一\")]),v._v(\" \"),a(\"li\",[v._v(\"软引通常用来实现内存敏感的缓存\")]),v._v(\" \"),a(\"li\",[v._v(\"在weakHashmap中就使用到了弱引用，相较于hashmap其存储数据在内存不足时会回收\")]),v._v(\" \"),a(\"li\",[v._v(\"虚引用必须和引用队列一起使用，创建时必须提供一个引用队列作为参数，即被虚引用引用的对象被回收时，将虚引用加入引用队列，以通知应用程序对象的回收情况\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"垃圾收集器\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#垃圾收集器\"}},[v._v(\"#\")]),v._v(\" 垃圾收集器\")]),v._v(\" \"),a(\"p\",[v._v(\"垃圾回收的并发，并行\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"并行：多条垃圾收集线程并行工作\")]),v._v(\" \"),a(\"li\",[v._v(\"并发：用户线程与垃圾收集线程同时执行（同一时间段的并行）\")])]),v._v(\" \"),a(\"p\",[v._v(\"评估GC的性能指标（在最大吞吐量优先的情况下，降低停顿时间）\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"吞吐量（运行用户代码的时间占总运行时间比例）\")]),v._v(\" \"),a(\"li\",[v._v(\"暂停时间（执行垃圾收集时，程序的工作线程被暂停的时间）\")]),v._v(\" \"),a(\"li\",[v._v(\"内存占用(Java堆区所占的内存大小)\")])]),v._v(\" \"),a(\"p\",[v._v(\"七款经典垃圾收集器\")]),v._v(\" \"),a(\"p\",[v._v(\"垃圾收集器的组合\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\垃圾收集器.PNG)\")])])]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\垃圾收集器组合.PNG)\")]),v._v(\" \"),a(\"p\",[v._v(\"(1)Serial回收器：串行回收（在用户的桌面应用场景中，可用内存一般几十Mb-100多Mb，可在较短时间内完成垃圾收集，对于交互较强的应用，不能接收，一般Java web应用程序不会采用串行垃圾收集器）\")]),v._v(\" \"),a(\"p\",[v._v(\"(2)ParNew回收器：并行回收\")]),v._v(\" \"),a(\"p\",[v._v(\"(3)Parallel Scavenge回收器：吞吐量优先（可控制吞吐量，即高效利用CPU时间完成任务，如执行批量处理，订单处理，工资支付等，吞吐量与STW相互制约，使用服务端）\")]),v._v(\" \"),a(\"p\",[v._v(\"(4)CMS回收器：低延迟（标清（不用标整，因为用户线程还在并发执行），缩短停顿时间，Java应用集中在互联网网站或B/S系统的服务端上）（四个环节）（缺点：碎片，若有大对象需分配，不得不提前触发Full GC/并发占用线程，吞吐量降低/无法处理浮动垃圾，即并发标记未标记的垃圾）（CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器（），它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作）\")]),v._v(\" \"),a(\"p\",[v._v(\"(5)G1回收器：区域分代化\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"（针对配置多核CPU及大容量内存的机器，用于替换掉JDK1.5中的CMS收集器，相较于CMS，G1还未有压倒性优势，比如在用户程序运行的过程中，G1无论为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS高，大内存选G1，平衡点大概在6-8GB）\")]),v._v(\" \"),a(\"li\",[v._v(\"（每次根据允许的收集时间，优先回收价值最大的\"),a(\"strong\",[v._v(\"Region\")]),v._v(\"（原有模式很难有突破，提出的分区Region概念，化整为零，叫做Humongous内存区域，用来存储大对象，超过1.5个region，就放到H），侧重点在与回收垃圾最大量的区间）\")]),v._v(\" \"),a(\"li\",[v._v(\"（仍然属于分代型垃圾回收器，从堆的结构上看，它不要求整个Eden区、年轻代、老年代时连续的，它将堆空间分为若干个区域，这些区域中包含了逻辑上的年轻代和老年代，故该收集器同时兼顾年轻代和老年代）(在延迟可控情况下获得尽可能高的吞吐量，故称为全全功能收集器\")])]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\G1.PNG)\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"G1垃圾回收过程主要包含三个环节：年轻代GC/老年代并发标记过程、混合回收（老年代old region对象过多，不是Old GC，除了回收整个Young Region，还会回收一部分Old Region）。还有个Full GC(但G1的初衷就是避免Full GC,一但需要调整（增大内存）)\")]),v._v(\" \"),a(\"li\",[v._v(\"Remembered Set(任何收集器都是使用Remembered Set来避免全局扫描)/每个Region都有一个对应的RememberedSet(Region不可能孤立，其有可能被其他区外对象引用)\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"字节码文件\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#字节码文件\"}},[v._v(\"#\")]),v._v(\" 字节码文件\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\JVM路线.PNG)\")]),v._v(\" \"),a(\"p\",[v._v(\"父子类输出变量（涉及显示初始化>构造器初始化）,Father son=new Son()，子类构造器与父类构造器调用一个方法x()，在实例化时调用的是子类的方法，方法中涉及的变量也是子类中未显示初始化的变量，son.属性调用的是父类的属性（属性不存在多态性）\")]),v._v(\" \"),a(\"p\",[v._v(\"class文件是以8位二进制流为基础，通过软件转化为易识别的16进制文件，涉及的是计算机通过识别不同的二进制码来执行不同的操作，\"),a(\"em\",[v._v(\"ASCII\")]),v._v(\"码就是将\"),a(\"em\",[v._v(\"机器码\")]),v._v(\"翻译成人类可以识别的编码（如一串二进制码转化为java/xx/xx）\")]),v._v(\" \"),a(\"p\",[v._v(\"方法所属的类，方法名称、参数、返回值类型\")]),v._v(\" \"),a(\"p\",[v._v(\"JDK解析class字节码文件其实就是标识为01的字符串过程（即最终指向字面量）\")]),v._v(\" \"),a(\"p\",[v._v(\"当真正进行类的加载，形成动态链接的时候(找到真正的内存入口地址)，此时才转化为直接引用\")]),v._v(\" \"),a(\"p\",[v._v(\"LineNumberTable刻画的就是字节码指令与代码之间的对应关系\")]),v._v(\" \"),a(\"p\",[v._v(\"JVM调优分为GC调优和代码层面调优\")]),v._v(\" \"),a(\"p\",[v._v(\"java -g xx.java(加-g 生成对应的局部变量表信息，IDEA等工具默认编译时有加上局部变量表信息)\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\javap.PNG)\")]),v._v(\" \"),a(\"p\",[v._v(\"常用-s/-l/-c/-v -verbose\")]),v._v(\" \"),a(\"h4\",{attrs:{id:\"字节码指令集与解析举例\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#字节码指令集与解析举例\"}},[v._v(\"#\")]),v._v(\" 字节码指令集与解析举例\")]),v._v(\" \"),a(\"p\",[v._v(\"Java虚拟机的指令由一个字节长度的代表则会某种特定操作含义的数字以及跟随其后的零至多个代表次操作所需参数而构成。意味着指令集的操作码总数不可能超过256条。\"),a(\"em\",[v._v(\"aload_0\")]),v._v(\" = 42 (0x2a)\")]),v._v(\" \"),a(\"h6\",{attrs:{id:\"加载与存储指令概述\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#加载与存储指令概述\"}},[v._v(\"#\")]),v._v(\" 加载与存储指令概述\")]),v._v(\" \"),a(\"p\",[v._v(\"作用：加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递\")]),v._v(\" \"),a(\"p\",[v._v(\"操作数栈：存放计算的操作数以及返回结果（执行每条指令之前，JAVA虚拟机要求该指令的操作数已经被压入操作数栈中，执行指令时，java虚拟机会将指令所需的操作数弹出，并且将指令的结果重新压入栈中）\")]),v._v(\" \"),a(\"p\",[v._v(\"局部变量表(数组)：字节码程序可以将计算的结果缓存在局部变量去之中（依次存放this指针(仅非静态方法)、所传入参数/字节码中的局部变量）\")]),v._v(\" \"),a(\"h5\",{attrs:{id:\"局部变量表压栈指令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#局部变量表压栈指令\"}},[v._v(\"#\")]),v._v(\" 局部变量表压栈指令\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\压栈指令.PNG)\")]),v._v(\" \"),a(\"p\",[v._v(\"常量入栈指令\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\常量入栈指令.PNG)\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\常量入栈指令1.PNG)\")]),v._v(\" \"),a(\"p\",[v._v(\"long/double占两个slot槽位\")]),v._v(\" \"),a(\"h5\",{attrs:{id:\"出栈装入栈局部变量表指令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#出栈装入栈局部变量表指令\"}},[v._v(\"#\")]),v._v(\" 出栈装入栈局部变量表指令\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\出栈装入栈局部变量表指令1.PNG)\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\出栈装入栈局部变量指令表2.PNG)\")]),v._v(\" \"),a(\"h5\",{attrs:{id:\"算数指令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#算数指令\"}},[v._v(\"#\")]),v._v(\" 算数指令\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\算数指令.PNG)\")]),v._v(\" \"),a(\"p\",[v._v(\"底层涉及i=i+10，与i+=10前一个分为从局部变量表中取出数据在放到操作数栈中进行相加，最后再放到局部变量表中，后一个只需再局部变量表中就能完成相加操作(一个指令就能完成)\")]),v._v(\" \"),a(\"p\",[v._v(\"声明完变量，初始值放入插槽就会出栈，做运算前是空栈\")]),v._v(\" \"),a(\"p\",[v._v(\"面试题(先++与后++)：其字节码操作指令完全一致，若涉及到与其他运算符一起计算的场景，\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM++i与i++PNG.PNG)\")]),v._v(\" \"),a(\"p\",[v._v(\"区别在于入栈指令在自增之前执行还是之后执行\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\自增覆盖问题.PNG)\")]),v._v(\" \"),a(\"h5\",{attrs:{id:\"比较指令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#比较指令\"}},[v._v(\"#\")]),v._v(\" 比较指令\")]),v._v(\" \"),a(\"p\",[v._v(\"比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈。\")]),v._v(\" \"),a(\"p\",[v._v(\"比较指令有：dcmpg,dcmpl,fcmpg,fcmpl,lcmp\")]),v._v(\" \"),a(\"p\",[v._v(\"04类型转换指令（主要是针对8种基本数据类型，分为宽化与窄化 ）\")]),v._v(\" \"),a(\"p\",[v._v(\"宽化（简化为int->long->float->double，如i2l,i2f）\")]),v._v(\" \"),a(\"p\",[v._v(\"会存在精度损失问题，不会抛出运行时异常\")]),v._v(\" \"),a(\"p\",[v._v(\"byte,short,char在内存中都看成int来处理，即没有转换时没有操作指令\")]),v._v(\" \"),a(\"p\",[v._v(\"窄化()\")]),v._v(\" \"),a(\"p\",[v._v(\"窄化中存在int转byte,short,char指令\")]),v._v(\" \"),a(\"p\",[v._v(\"05对象的创建与访问指令\")]),v._v(\" \"),a(\"p\",[v._v(\"创建对象时通过字节码指令，与类的加载对比分析（执行该字节码指令是否属于初始化）\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"类的加载过程详解\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#类的加载过程详解\"}},[v._v(\"#\")]),v._v(\" 类的加载过程详解\")]),v._v(\" \"),a(\"p\",[v._v(\"初始化后会在方法区存放类的模板，然后就可以使用，通过调用该类的静态方法或实例化创建类的对象\")]),v._v(\" \"),a(\"p\",[v._v(\"类将.class文件文件加载至元空间后，在堆中创建一个class对象，用来封装类位于方法区内的数据结构，该class对象时在加载类的过程中创建的，每个类都有对应有一个CLAss类型的对象\")]),v._v(\" \"),a(\"p\",[v._v(\"到初始化时n\")]),v._v(\" \"),a(\"p\",[v._v(\"，涉及到的都是类的初始化，不涉及到非静态变量\")]),v._v(\" \"),a(\"p\",[v._v(\"static final通过使用new赋值，并不会在属性字段处生成引用，而是在method中clint方法中通过字节码操作指令生成对应的字段\")]),v._v(\" \"),a(\"p\",[v._v(\"通过解析操作，符号引用节可以转变为目标方法在类中方法表的位置，从而使得方法成功调用\")]),v._v(\" \"),a(\"p\",[v._v(\"类初始化阶段的重要工作时执行类的初始化方法clint方法（该方法由Java编译器生成由JVM调用，它是由类静态成员的赋值语句以及static语句块合并而成的）\")]),v._v(\" \"),a(\"p\",[v._v(\"在初始化阶段,jvm调用初始化方法为类变量赋值\")]),v._v(\" \"),a(\"p\",[v._v(\"字段哪种场景下才有clint方法（类中需有static字段且显示赋值(非调用方法的final static也有)）\")]),v._v(\" \"),a(\"p\",[v._v(\"final+static在链接的准备阶段赋值的情况\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"对于基本数据类型的字段来说，显示赋值（直接赋值常量，而非调用方法）\")]),v._v(\" \"),a(\"li\",[v._v(\"对于String来说，如果使用字面量方式赋值\")])]),v._v(\" \"),a(\"p\",[v._v(\"可总结为显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显示赋值，是在链接阶段的准备环节进行的\")]),v._v(\" \"),a(\"p\",[v._v(\"clint方法的线程安全性：虚拟机会保证一个类的clint方法在多线程环境下被正确的加锁同步，如果多个线程同时去初始化一个类，那么只有一个线程会去执行这个类的clint方法，其他线程都需要阻塞等待，直到活动线程执行clint方法\")]),v._v(\" \"),a(\"p\",[v._v(\"Java程序对类的使用分为两种，主动使用（才会使用clint）与被动使用，class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型（并不是在代码中出现的类，就一定会被初始化，如果不符合主动使用的条件，类就不会初始化）\")]),v._v(\" \"),a(\"p\",[v._v(\"首次调用需要主动使用(调用clint)，后面程序员使用无需再clint（我的理解是调用static方法属性（调用方法的）则会调用clint方法，跟Init构造器方法无关，只是对静态属性方法赋值，给调用的类使用），其只执行一次\")]),v._v(\" \"),a(\"p\",[v._v(\"基本数据类型由虚拟机预先定义，引用数据类型需要进行类的加载\")]),v._v(\" \"),a(\"h5\",{attrs:{id:\"类的卸载\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#类的卸载\"}},[v._v(\"#\")]),v._v(\" 类的卸载\")]),v._v(\" \"),a(\"p\",[v._v(\"![](D:\\\\soft\\\\IntelliJ IDEA\\\\资料\\\\导图笔记\\\\图片\\\\JVM\\\\类加载器关联.PNG)\")]),v._v(\" \"),a(\"h4\",{attrs:{id:\"jvm调优\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jvm调优\"}},[v._v(\"#\")]),v._v(\" JVM调优\")]),v._v(\" \"),a(\"p\",[v._v(\"为什么要调优：防止出现OOM、解决OOM、减少Full GC出现的频率\")]),v._v(\" \"),a(\"p\",[a(\"strong\",[v._v(\"性能优化的步骤\")]),v._v(\"：\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"性能监控（发现问题----GC频繁、cpu load过高、OOM、内存泄漏、死锁、程序响应时间过长）\")]),v._v(\" \"),a(\"li\",[v._v(\"性能分析（排查问题-----GC日志、命令行、监控工具、jstack查看堆栈）\")]),v._v(\" \"),a(\"li\",[v._v(\"性能调优（解决问题-----增加内存，选择合适的回收器、优化代码、增加机器、合理的线程数、使用中间件，缓存，消息队列等、其他）\")])]),v._v(\" \"),a(\"p\",[v._v(\"调优指标：停顿时间（或响应时间）、吞吐量、并发数、内存占用、相互间关系\")]),v._v(\" \"),a(\"p\",[v._v(\"命令行篇：\")]),v._v(\" \"),a(\"p\",[v._v(\"(1)jps查看正在运行的Java进程（-l全类名 -m主程序传参 -v进程JVM参数）\")]),v._v(\" \"),a(\"p\",[v._v(\"(2)jstat查看JVM统计信息(常用于检测垃圾回收与内存泄漏问题，没有GUI时是运行期定位虚拟机性能问题的首选工具)\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[v._v(\"-class xxid显示类加载、卸载、耗时 (类相关)\")]),v._v(\" \"),a(\"p\",[v._v(\"jstat -class -t  -h表头次数 进程号 -时间 -次数\")])]),v._v(\" \"),a(\"li\",[a(\"p\",[v._v(\"垃圾回收相关(重点)\")]),v._v(\" \"),a(\"p\",[v._v(\"挖掘信息（jstat -gc -t  xxid 间隔 次数）（如打印10次的时间，与GC间隔时间，如果GC总时间占比超过20%说明堆的压力有点大，如果超过90%说明堆里几乎没有可用空间，随时都可能抛出OOM异常）\")]),v._v(\" \"),a(\"p\",[v._v(\"（判断内存泄漏）（jstat -gc -t  xxid 间隔 次数）（如多次命令，随机抽取其中OU的最小值，如果这些值呈现出上涨趋势，说明程序的老年代内存已使用量在不断上涨，可能存在内存泄漏）\")])]),v._v(\" \"),a(\"li\",[a(\"p\",[v._v(\"JIT相关\")]),v._v(\" \"),a(\"p\",[v._v(\"-compiler显示JIT编译信息\")]),v._v(\" \"),a(\"p\",[v._v(\"-printcompilation编译过的方法\")])])]),v._v(\" \"),a(\"p\",[v._v(\"（3）jinfo（查看虚拟机配置参数信息，可用于调整虚拟机的配置参数（运行时可修改））\")]),v._v(\" \"),a(\"p\",[v._v(\"（4）jmap（导出内存映像文件&内存使用情况）\")]),v._v(\" \"),a(\"p\",[v._v(\"（5）jhat（（JDK自带堆分析工具，JDK9,10被替代）内置了HTTP/HTML服务器，生成dump文件的分析结果，用户可在浏览器中查看分析结果）\")]),v._v(\" \"),a(\"p\",[v._v(\"（6）jstack打印JVM中线程快照\")]),v._v(\" \"),a(\"p\",[v._v(\"（7）jcmd（多功能命令行，建议替换jmap）\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"开发工具\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#开发工具\"}},[v._v(\"#\")]),v._v(\" 开发工具\")]),v._v(\" \"),a(\"p\",[v._v(\"开发中常用\")]),v._v(\" \"),a(\"p\",[v._v(\"(1)Visual VM\")]),v._v(\" \"),a(\"p\",[v._v(\"远程：可调用远程服务的JAVA进程去监控其他服务器的服务性能(ip,jmx该文件，将服务器地址变为公网地址，防火墙等等)\")]),v._v(\" \"),a(\"p\",[v._v(\"场景：运维通过JMP生成dump传给我，可以使用Visual vm读取装入\")]),v._v(\" \"),a(\"p\",[v._v(\"主要功能：生成/读取堆内存快照--查好看JVM参数、系统属性--查看运行虚拟机进程--生成、读取线程快照--实时监控--其他功能\")]),v._v(\" \"),a(\"p\",[v._v(\"MAT用于发现内存泄漏问题（重点在于获取堆dump文件和分析堆dump文件）(为开发人员生成内存泄漏报表)\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"histogram（实例数目、实例信息等）\")]),v._v(\" \"),a(\"li\",[v._v(\"thread overview（java线程、局部变量信息）\")]),v._v(\" \"),a(\"li\")]),v._v(\" \"),a(\"p\",[v._v(\"建议选择vm+阿尔萨斯+jp\")]),v._v(\" \"),a(\"p\",[v._v(\"第三章是调优的精华\")]),v._v(\" \"),a(\"p\",[v._v(\"追求机制性能的场景下，了解你的程序运行中cpu在干什么，火焰图就是一种非常直观的展示cpu在程序整个声明周期过程中时间分配的工具，如果你想改善接口，提高极致的性能，就可以选择火焰图\")]),v._v(\" \"),a(\"p\",[v._v(\"在JDK6后默认开启了逃逸分析和标量替换\")]),v._v(\" \"),a(\"p\",[v._v(\"xms与xmx设置未fullgc后老年代内存占用3-4倍，元空间设置为老年代存活对象（都是FULLGC后）的1.2-1.5，年轻代xmn为老年代存活对象1-1.5\")])])}),[],!1,null,null,null);_.default=r.exports}}]);","extractedComments":[]}