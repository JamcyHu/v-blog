{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{411:function(a,e,s){\"use strict\";s.r(e);var t=s(56),n=Object(t.a)({},(function(){var a=this,e=a.$createElement,s=a._self._c||e;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[s(\"h4\",{attrs:{id:\"集合\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#集合\"}},[a._v(\"#\")]),a._v(\" 集合\")]),a._v(\" \"),s(\"p\",[a._v(\"Collection接口\\nlist,set,queue\")]),a._v(\" \"),s(\"p\",[a._v(\"map接口\")]),a._v(\" \"),s(\"p\",[a._v(\"区别：存户有无序，重复问题()\\n选用集合情况，键值对，map，元素值，collection接口下集合\")]),a._v(\" \"),s(\"p\",[a._v(\"各自的实现类\\nlist->\\narraylist,vector,linkedlist====数据结构，\\nArraylist 和 Vector 的区别\\nArraylist 与 LinkedList 区别(主要)===线程安全，数组结构，插入删除时间，快速访问，空间占用\")]),a._v(\" \"),s(\"p\",[a._v(\"arraylist扩容机制，三种初始（无参构造（add才分配，10，1.5），带参数初始化，传集合）\")]),a._v(\" \"),s(\"p\",[a._v(\"set->\\nhashset,linkedhashset,treeset(唯一有序红黑树)====数据结构，\\ncomparable（lang包） 和 Comparator(util) 排序\\n三个实现类异同，数据结构异，场景异，同唯一非安全。\\nhashset重复问题(对象hashcode,相同调用equals())\\nhashcode与equals（）问题\\n==与equals()区别\")]),a._v(\" \"),s(\"p\",[a._v(\"queue->\\npriorityqueue,arrayqueue====数据结构，\\n先进先出，\\nArrayDeque 与 LinkedList 的区别\")]),a._v(\" \"),s(\"p\",[a._v(\"map->\\nhashmap,linkedHashmap,hashtable,treemap====数据结构，\\nhashmap与hashtable区别（线程，数据结构（链表转转换红黑树问题），null，效率，初始容量扩容（两种扩容））\\nhashmap与hashset（实现，对象，方法，hashcode）\\nhashmap与treemap\\nhashmap底层(HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置，扰动函数(h = key.hashCode()) ^ (h >>> 16))\\nhashmap遍历\\nConcurrentHashMap 和 Hashtable （数据结构，线程安全（synchronized 和 CAS ，synchronized））\")]),a._v(\" \"),s(\"p\",[a._v(\"Collections工具类：\\n方法：排序，替换，同步控制(推荐juc)\")]),a._v(\" \"),s(\"p\",[a._v(\"集合遍历问题，并发情况下，ConcurrentModificationException，fail-fast 机制。要在 foreach 循环里进行元素的 remove/add 操作\")]),a._v(\" \"),s(\"h2\",{attrs:{id:\"jvm\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jvm\"}},[a._v(\"#\")]),a._v(\" JVM\")]),a._v(\" \"),s(\"h4\",{attrs:{id:\"内存区域\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#内存区域\"}},[a._v(\"#\")]),a._v(\" 内存区域\")]),a._v(\" \"),s(\"p\",[a._v(\"运行时数据区域(线程私有，共享)\")]),a._v(\" \"),s(\"ol\",[s(\"li\",[s(\"p\",[a._v(\"程序计数器（代码流程控制，记录当前线程执行位置）\")])]),a._v(\" \"),s(\"li\",[s(\"p\",[a._v(\"Java虚拟机栈(栈帧组成，栈帧成分（局部变量）)\\n错误类型\")])]),a._v(\" \"),s(\"li\",[s(\"p\",[a._v(\"本地方法栈（虚拟机native方法）\")])]),a._v(\" \"),s(\"li\",[s(\"p\",[a._v(\"堆（放对象实例，非所有对象都在栈分配， JIT 编译器的发展与逃逸分析技术）\\n垃圾收集主要区域，分代，分区，目的，分配流程，错误原因（回收时间，内存空间）\")])]),a._v(\" \"),s(\"li\",[s(\"p\",[a._v(\"方法区/元空间（存储东 西，参数，运行时常量池（Class文件，常量池表））\\n3.直接内存，OutOfMemoryError\")])])]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"虚拟机在Java堆中对象分配、布局、访问\\n创建对象过程\\n对象布局：对象头，实例数据，对其填充\\n对象访问：句柄，直接指针，好处\")])]),a._v(\" \"),s(\"p\",[a._v(\"字符串常量池（提升性能和减少内存消耗针对字符串）问题：字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，引用的值在程序编译期是无法确定的\")]),a._v(\" \"),s(\"h4\",{attrs:{id:\"垃圾回收\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#垃圾回收\"}},[a._v(\"#\")]),a._v(\" 垃圾回收\")]),a._v(\" \"),s(\"p\",[a._v(\"Java内存自动管理（核心堆内存中对象的分配和回收）\\n堆空间基本结构\\n对象分配流程(新对象，大对象，长期存活，年龄判定)\\n参数\\n各种GC(full,partial,)\")]),a._v(\" \"),s(\"p\",[a._v(\"对象死亡（回收前提）：引用计数，可达性\\n各种引用\\n废弃变量，无用类（实例，加载器，，class对象）\")]),a._v(\" \"),s(\"p\",[a._v(\"分代垃圾收集算法（标清，标复，标整）缺点，选择问题\\n垃圾收集器：serial，ParNew，\")]),a._v(\" \"),s(\"h4\",{attrs:{id:\"类文件结构-class文件\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#类文件结构-class文件\"}},[a._v(\"#\")]),a._v(\" 类文件结构(class文件)\")]),a._v(\" \"),s(\"h4\",{attrs:{id:\"类加载过程\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#类加载过程\"}},[a._v(\"#\")]),a._v(\" 类加载过程\")]),a._v(\" \"),s(\"p\",[a._v(\"加载，连接（验证，准备，解析），初始化（真正执行类中定义java代码，情况）\")]),a._v(\" \"),s(\"p\",[a._v(\"使用，卸载（要求）\")]),a._v(\" \"),s(\"p\",[a._v(\"类加载详解：\\n类加载器(路径)\\n双亲委派机制，好处（避免重复加载）\")]),a._v(\" \"),s(\"h4\",{attrs:{id:\"\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#\"}},[a._v(\"#\")])]),a._v(\" \"),s(\"p\",[a._v(\"JVM参数\\n1.堆内存\\n-Xms -Xmx （具体）\"),s(\"br\"),a._v(\"\\n-XX:NewSize=xx/-Xmn256m  -XX:MaxNewSize=xx 新生代    尽可能将对象分配在新生代   -XX:NewRatio=1新生代和老年代比值\")]),a._v(\" \"),s(\"p\",[a._v(\"元空间：\\n-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）\\n-XX:MaxMetaspaceSize=N\")]),a._v(\" \"),s(\"p\",[a._v(\"垃圾收集器：\\n-XX:+UseSerialGC\\n-XX:+UseParallelGC\\n-XX:+UseParNewGC\\n-XX:+UseG1GC\")]),a._v(\" \"),s(\"p\",[a._v(\"GC记录\\n-XX:+UseGCLogFileRotation\\n-XX:NumberOfGCLogFiles=< number of log files >\\n-XX:GCLogFileSize=< file size >[ unit ]\\n-Xloggc:/path/to/gc.log\")]),a._v(\" \"),s(\"h2\",{attrs:{id:\"java\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#java\"}},[a._v(\"#\")]),a._v(\" Java\")]),a._v(\" \"),s(\"h4\",{attrs:{id:\"并发\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#并发\"}},[a._v(\"#\")]),a._v(\" 并发\")]),a._v(\" \"),s(\"p\",[a._v(\"线程与进程（关系，区别，优缺点）\\n多线程优缺点\\n线程生命周期和状态\")]),a._v(\" \"),s(\"p\",[a._v(\"synchronized（目的，修饰对象（给xx加锁，进入xx（不是方法/代码块是对象）要获得xx的锁），经典应用,底层原理（代码块，方法），JDK1.6优化，与reentrantlock区别）\\nvolatile(Java内存模型，并发编程3个特性，与synchronized区别)\\nthreadlocal（目的（访问这个变量的每个线程都会有这个变量的本地副本），原理，内存泄漏）\\n线程池(好处，4种创建线程方式，2种创建线程池方式，ThreadPoolExecutor类分析（参数）)\")])])}),[],!1,null,null,null);e.default=n.exports}}]);","extractedComments":[]}