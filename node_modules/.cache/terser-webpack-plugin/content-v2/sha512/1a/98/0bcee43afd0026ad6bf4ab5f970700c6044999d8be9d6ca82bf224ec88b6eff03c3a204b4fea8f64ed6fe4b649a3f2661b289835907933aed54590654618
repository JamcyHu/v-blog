{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{406:function(e,n,t){\"use strict\";t.r(n);var i=t(56),s=Object(i.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[t(\"p\",[e._v(\"订单服务(线程池配置 springsession配置 会员拦截器 threadlocal<MemberRespVo>loginUser.set(attribute) 实现webmvcconfigurer添加路径):\\n一去结算\\n1订单确认页抽取(地址信息s 所有购物项s 优惠卷 订单总额 应付价格  token）\"),t(\"br\"),e._v(\"\\n2订单数据获取(远程查地址(memberRespVo.getid)  远程查购物项(购物车拦截器 cartkey获取购物项(远程skuid查最新价格) 抽取购物项实体类有货  .thenRunAsync由skuids远程调库存查购物项有无货)  memberrespvo设置积分  总额价格在vo计算)   （feign远程调用请求头丢失，cart认为没登陆   需要自定义feign拦截器(requestcontextholder.getrequestattribute 原理threadlocal  attributes.getrequest获取请求  请求不为空(再获取头，template.header()放入新请求))）不带头无法确定属于哪个购物车\\n（使用线程池,主线程requestcontextholder.getattr, 异步中set  原理是threadlocal）\\nuuid token令牌 放入redis和订单确认vo  ajax表单\\n二提交订单（ordersubmitvo实体类 addrid paytype token payprice)（创单(Ordercreateto(order orderitems payprice fare)),验令牌，验价，锁库存）\\n(接口幂等（token,锁，唯一id，防重表,唯一约束） 多点，回点，fegin重试机制  使用token 先后删令牌都有问题 获取,对比,删除(原子性) redis中lua脚本)\\n1创单 2验令牌(拦截器获取用户 取redis中token lua脚本) 3验成功(创单(orderentity orderitementity)  4验价  try/catch5锁库存(Stock skuid wardid,num)stock.set wareSkuDao查仓库ids编写sql语句 遍历stock取skuid, wardids 再遍历wardid wareskudao编写sql(skuid,wardid,num)去锁库存)\\n( 可靠消息+最终一致性 加一个锁库存记录 不用定时任务(消耗内存，增加数据库压力，存在时间误差)，延时队列  死信路由(消息拒收,ttl时间,队列满丢前面消息)\\nconfiguration bean创建quueu,exchange,binding  库存服务配置消息json @enablerabbit 第一次连上rabbitmq才创建 )\\n远程锁库存问题:1下订单成功，没支付，库存回滚 2库锁成功，下面得业务失败，库存解锁（锁库存方法，保存库存工作单  锁成功，保工作单详情，给mq发消息(to(工作单id,详情工作单))  监听队列，取to中detailid查详情工作单 有解锁(to中工作单id查订单号 远程调订单服务查订单详情 订单状态取消/订单不存在 解锁库存unlockstock(工作单中skuid,num,) 手动回复/拒绝策略  更新库存工作单详情) 无即锁库存失败，不用解锁）\\n定时关闭订单:下订单中 锁库存成功后定时释放订单服务（还要发消息给库存队列 查库存状态 未解锁则调用解锁方法）\\n）\")]),e._v(\" \"),t(\"p\",[e._v(\"数据库事务隔离级别  事务传播行为\\n分布式事务 cap定 base理论(基本可用，实现最终一致)  分布式系统raft算法实现一致性  分布式事务方案(2pc对应seata,完成一个事务需要加很多锁,不适合高并发)\")]),e._v(\" \"),t(\"p\",[e._v(\"三去支付（非对称加密 私钥加签，公钥验签 线上切换支付宝网关url即可 同步和异步通知页面地址（需要内网穿透）uft8）\\n1整合支付(导入阿里sdk 导入alitemplate配置类(pay方法中有aliclient发请求返回页面) 编写接口传订单号查订单信息，调用ali.pay(),返回vo\"),t(\"br\"),e._v(\"\\n2支付成功同步回调会员页面（登录判断）\\n3会员远程调用订单分页 )\")]),e._v(\" \"),t(\"p\",[e._v(\"秒杀服务:\\n后台添加场次 关联商品\\n使用异步+定时任务  在config类中使用@EnableAsync @EnableScheduling 配置文件可指定线程池\\n一商品上架\\n1定时扫描活动得商品（远程调优惠服务 查最近三天活动 活动商品关联表 缓存放入redis活动(商品id)和活动商品信息redisTo(远程获sku基本数据，秒杀信息，随机码，redisson信号量(配置redissonclient)) 放入redis的数据都要判断 分布式锁+redistemplate.haskey()有就不用放入(定时任务商品上架幂等性问题)） ）\\n2加分布式锁\\n二查询秒杀商品\\n1去redis中获取当前参与秒杀的商品\\n2前端ajax\\n三商品详情页渲染（商品服务）\\n1 前端传skuid 绑定商品详情前缀key  遍历hash中所有key 用正则+skuid匹配  取出商品信息 处于活动时间才传随机码 商品服务调用\\n四秒杀商品的抢购（如何设计一个高并发的系统）\\n一设计(1独立服务2链接加密3库存预热,快速扣减(正常流程占库存太慢预加载)4动静分离)\"),t(\"br\"),e._v(\"\\n5网关拦截恶意请求  6流量错峰（验证码，购物车流程）7限流(前端点击次数，后端不合理请求，请求多次)熔断降级 8队列削峰\\n二秒杀抢购接口（session拦截器，config配置cookie域  1前端传killid,key,num\"),t(\"br\"),e._v(\"\\n2两套购物流程）\\n（1登录判断 2合法性校验（取得商品信息判断是否空 时间、随机码、商品id、数量（是否重复购买 幂等性需要redis占位redistemplate.opsforvalue().setifabsent（userid_sessionid_skuid），成功说明没买过））3获取信号量（client.get  semaphore.tryacquire(num) ）4信号量成功,发送mq消息，返回订单号，订单服务监听(创单，保存订单，订单项)   直接去支付）\")]),e._v(\" \"),t(\"p\",[e._v(\"事务从web的ThreadLocal开始，折磨到Spring的声明式事务，再到现在的分布式事务。\")]),e._v(\" \"),t(\"p\",[e._v(\"谷粒商城\\n优化点\\n难点，解决方案，达到什么目的\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"分布式锁\")]),e._v(\" \"),t(\"li\",[e._v(\"分布式事务方案的选取\\n亮点\")])]),e._v(\" \"),t(\"p\",[e._v(\"ioc aop源码\\nspring中bean的生命周期\\n面试官，你好，我叫连楚滨，目前就读于韩山师范学院大三，对java的一些技术生态，还有一些spring框架是比较熟悉的，对jvm原理有一定理解，数据库方面主要使用的是Mysql,熟悉redis的使用, 然后前端像thymeleaf模板引擎或vue框架能做到基本的使用，之前做过的项目主要有两个，第一个网上购物的电商系统，第二个项目是在线教育视频网站，主要说下最近的电商系统，电商系统是一个偏业务的系统，我在小组中的角色是后端系统开发，主要是负责以下，一是分析功能的需求，实现代码的编写，二设计系统的架构，使用springboot+mybatisplus+springcloud的搭建分布式系统，实现服务的模块化，增强系统可扩展性。三使用一些消息中间件redis,rabbitmq对复杂的系统进行解耦，瞬时流量削峰，解决一些分布式事务，接口幂等性，分布式锁的问题。四，通过自定义线程池，应对该项目中高并发情况下线程问题，降低系统资源的消耗，提高响应速度。大概的情况就是这样。\")]),e._v(\" \"),t(\"p\",[e._v(\"最近在做的项目是一个电商系统，采用微服务架构，我主要是负责以下的几个功能模块，认证服务，分为注册和登录，注册使用的阿里云的短信服务进行验证，登录分为普通登录和社交登录，使用oAuth2协议进行微博登录，获取用户信息，将用户信息放入分布式session中。购物车服务中，分为用户购物车和游客购物车，存在判断购物车类型和购物车合并的问题，通过定义拦截器获取session，使用ThreadLocal为使用用户信息变量的线程提供独立的副本，利用redis存储个人信息，判断购物车类型，基于购物车类型判断是否合并。订单服务，分为三步，一是去结算，使用异步编排生成订单确认页，存在feign远程调用请求头丢失的问题，对此我定义fegin拦截器通过requestcontextholder同步请求的cookie，实现请求传递；二是提交订单，这是一个幂等性操作，我对此使用lua脚本进行token令牌验证，还存在锁库存失败回滚的问题，使用mq队列，采用可靠消息+最终一致性实现库存解锁。三是去支付，整合支付宝的沙箱环境。秒杀服务具有瞬间高并发的特点，对此我主要采用了异步，redis缓存，mq消息队列来应对瞬间高流量，实现秒杀服务的独立运行。以上就是我的介绍。\")]),e._v(\" \"),t(\"p\",[e._v(\"让业务以异步的方式运行\\n，自己提交到线程池大致的情况就是这样\\n难点：分布式锁\\nkolp-\\nkfk2112162e339e请牢记订单号，订单卡密查询与订单投诉必须输入订单号\")])])}),[],!1,null,null,null);n.default=s.exports}}]);","extractedComments":[]}