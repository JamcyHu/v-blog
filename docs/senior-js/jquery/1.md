# JVM

程序-框架-API-JVM

JVM机构模型: Java编译器输入的指令流基本上是属于一种栈的指令集架构（移植性好），一种基于寄存器的指令集架构（性能好）。

![](/img/jvm/JVM架构.PNG)

由于跨平台的设计，JAVA的指令都是根据栈来设计的

虚拟机的启动:JAva虚拟机的启动时通过引导类加载器创建一个初始类来完成的，这个类是由虚拟机的具体实现指定的

HotSpot VM一次编译，处处运行

java代码必须要先编译成字节码文件，jvm才能正确识别代码转换后的指令并将其运行。在cpu层面看来计算机中所有的操作都是一个个指令的运行汇集而成的

class文件本质上是一个以8位字节为基础单位的二进制流

JIT编译器（just in time 即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为(Hot Spot Code 热点代码，为了提高热点代码的执行效率，**在运行时**，虚拟机将会把这些**代码编译成与本地平台相关的机器码**，并进行各层次的优化。

## 二 类加载子系统

#### 内存结构概述
中间部分就是java虚拟机定义的各种运行时数据区域
![](/img/jvm/jvm.PNG)
#### 类加载器与类的加载过程

classloader只负责class文件的加载，运行由executionengine决定

CLASS File被加载到JVM，称为DNA元数据模板，放在方法区，根据这个文件实例化出N个实例

.class文件->JVM->最终成为元数据模板(方法区)，需要运输工具(Class Loader)
#### 类加载过程
加载-》链接（验证，准备，解析）-》初始化

- 类的生命周期
1. 加载（由类名取二进制流/字节流静态结构变方法去区运行时结构/内存中生成对象作为方法区这些数据的访问入口），可通过自定义类加载器重写loadClass()方法控制字节流的获取。
注：数组类不需类加载器，直接由虚拟机创建。

虚拟机做了三件事：
通过一个类的全限定名来获取其定义的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。（通过堆class对象访问方法区中的这些数据）
2. 链接
（1）验证：是否符合虚拟机要求（如专属工具解析class文件开头CA FE BA BE,能被java虚拟机识别的有效起始和其他验证）
（2）准备：    为类静态变量分配内存（在方法区分配）设置初始值（默认值）的阶段（如赋值为3，put static指令是在程序编译后，存放于类构造器clinit()方法之中）
注：不包含final（常量）修饰的static，编译时就已赋值
（3）解析（常常量池内符号引用转换为直接引用（直接指向目标的指针或间接定位对象的句柄等）的过程））
3. 初始化（执行类构造器&lt;client&gt;()方法(由静态类变量显示赋值代码和静态代码块组成，只执行一次)的过程 ）
**类初始化时机**：
（1）创建类的实例，也就是new的方式 
（2）访问某个类或接口的静态变量，或者对该静态变量赋值 
（3）调用类的静态方法 
（4）反射(如Class.forName("com.pdai.jvm.Test")) 
（5）初始化某个类的子类，则其父类也会被初始化 
（6 ）Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类

使用：类访问方法区内的数据结构的接口， 对象是Heap区的数据。

卸载：类的Class对象被GC
卸载同时满足要求：
（1）类实例对象都被GC
（2）该类没有其他地方被引用
（3）类的类加载器实例已被GC

注：JVM自带的类加载器加载的类不会被卸载，自带类加载器会加载JDK提供的类，所以类加载器实列不会被回收。



两个工具（一个将class文件转换为16进制表示，一个展示出class文件的全部结构）

- 类加载器分类

1. 启动类加载器（bootstrap classloader负责加载存放在JDK\jre\lib，用来加载java核心类库，加载扩展类和应用程序类加载器）
2. 扩展类加载器（Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，开发者可以直接使用扩展类加载器。
3. 应用程序类加载器: Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
 


- JVM类加载机制
1. 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入(还是遵循双亲委派)，除非显示使用另外一个类加载器来载入
2. 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据（磁盘），并将其转换成Class对象，存入缓存区。**这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效**
3. 双亲委派机制，如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。（若最后AppClassLoader也加载失败，则会报出异常ClassNotFoundException）
  
双亲委派机制优势：(1)系统类防止内存中出现多份同样的字节码。(2)保证Java程序安全稳定运行。

- 自定义类加载器(JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件)
通常都是直接使用系统类加载器，有时需要自定义类加载器（应用是通过网络传输Java类的字节码，为安全这些字节码都经过加密，系统类加载器无法对其进行加载）

自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。

## 内存区域
- 虚拟机自动内存管理机制下(内存控制圈交予虚拟机)，不需要为new操作写delete/free操作，不容易出现内存泄漏和内存溢出问题，若出现需要了解虚拟机如何使用内存才能排查错误。

#### 运行时数据区（虚拟机将管理的内存划分为不同的数据区域）
注：垃圾回收（堆，方法区），OOM（堆，方法区，虚拟机栈，本地方法栈）

- 共享
1. 堆（存放对象实例，几乎所有的对象实例以及数组都在这里分配内存）
内存划分：GC堆区域新生代，老年代，永久代，JDK8后老年代被元空间取代（更好地回收内存，或者更快地分配内存） 
（1）年轻代：年轻代是所有新对象创建的地方。执行垃圾收集。这种垃圾收集称为 Minor GC。分为三个部分——伊甸园（Eden Memory）和两个幸存区（Survivor Memory，被称为from/to或s0/s1），默认比例是8:1:1
（2）老年代：旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象或大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。
（3）元空间（非堆中的）：
对象通常在Eden区分配，新生代垃圾回收后，存活则进入S0或S1，年龄+1，年龄默认15时晋升到老年代。

堆内存：-Xms 用来表示堆的起始内存，等价于 -XX:InitialHeapSize。
-Xmx 用来表示堆的最大内存，等价于 -XX:MaxHeapSize。超过抛出OutOfMemoryError 异常。

通常会将 -Xmx 和 -Xms 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能 默认情况下，初始堆内存大小为：电脑内存大小/64 默认情况下，最大堆内存大小为：电脑内存大小/4

堆内存分配：
在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小 默认情况下新生代和老年代的比例是 1:2，可以通过 –XX:NewRatio 来配置 新生代中的 Eden:From Survivor:To Survivor 的比例是 8:1:1，可以通过 -XX:SurvivorRatio 来配置 若在 JDK 7 中开启了 -XX:+UseAdaptiveSizePolicy，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄 此时 –XX:NewRatio 和 -XX:SurvivorRatio  将会失效，而 JDK 8 是默认开启-XX:+UseAdaptiveSizePolicy 在 JDK 8中，不要随意关闭-XX:+UseAdaptiveSizePolicy，除非对堆内存的划分有明确的规划 每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小 计算依据是GC过程中统计的GC时间、吞吐量、内存占用量

**GC堆垃圾回收**：JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。

针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full  GC） 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：
新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集
目前，只有 CMS GC 会有单独收集老年代的行为 很多时候 Major GC 会和 Full GC  混合使用，需要具体分辨是老年代回收还是整堆回收 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集
目前只有 G1 GC 会有这种行为 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾

**TLAB**（内存模型角度非垃圾回收分代角度）：对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内 多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为快速分配策略

TLAB作用：


注：**随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。**从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。

**逃逸分析**(虚拟机优化技术)：可以有效减少Java程序中同步负载和内存堆分配压力的算法。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的**对象的引用的使用范围**从而决定**是否要将这个对象分配到堆上**。

逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。对象被外部方法引用，则认为发生逃逸，如作为参数传递到其他方法(方法逃逸)或对象作为返回值传递到其他方法（线程逃逸）

逃逸分析，编译器对代码做了哪些优化：
（1）**栈上分配**：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配（**JIT 编译器在编译期间根据逃逸分析的结果**，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配，变量在栈上出栈就能释放资源，减少临时对象在堆内分配的数量）

（2）**同步省略**：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步（在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断**同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程**。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。这个**取消同步**的过程就叫做同步省略，也叫锁消除）
```java
public void keep() {
  Object keeper = new Object();
  synchronized(keeper) {
    System.out.println(keeper);
  }
}
//代码中对 keeper 这个对象进行加锁，但是 keeper 对象的生命周期只在 keep()方法中，并不会被其他线程所访问到，所以在 JIT编译阶段就会被优化掉。同步省略为
public void keep() {
  Object keeper = new Object();
  System.out.println(keeper);
}
```
（3）**分离对象或标量替换**：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器（标量（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。可以分解的数据叫做聚合量（Aggregate），Java 中的对象就是聚合量。
在 JIT 阶段，通过逃逸分析确定该**对象不会被外部访问，并且对象可以被进一步分解时**，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。这个过程就是标量替换。 通过 -XX:+EliminateAllocations 可以开启标量替换，-XX:+PrintEliminateAllocations 查看标量替换情况。）
```java

public static void main(String[] args) {
   alloc();
}

private static void alloc() {
   Point point = new Point（1,2）;
   System.out.println("point.x="+point.x+"; point.y="+point.y);
}
class Point{
    private int x;
    private int y;
}
//替换为如下
private static void alloc() {
   int x = 1;
   int y = 2;
   System.out.println("point.x="+x+"; point.y="+y);
}
```


3. 方法区（存储类信息、常量池、静态变量、JIT编译后的代码等数据）

注： 方法区和永久代的关系很像 Java 中接口和类的关系，永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。

JDK1.8移除了永久代（PermGen），替换为元空间（Metaspace）；替换原因：内存溢出几率变小。加载更多类信息。

运行时常量池：（Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用））

（1）在加载类和结构到虚拟机后，就会创建对应的运行时常量池 
（2）常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中 
（3）JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的 运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。
**运行时常量池，相对于 Class 文件常量池的另一个重要特征是：动态性，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 intern() 方法就是这样的**

常用参数（元空间）：-XX:MetaspaceSize=N   -XX:MaxMetaspaceSize=N

默认值依赖于平台。Windows 下，-XX:MetaspaceSize 是 21M，-XX:MaxMetaspacaSize 的值是 -1，即没有限制 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据发生溢出，虚拟机一样会抛出异常 OutOfMemoryError:Metaspace

-XX:MetaspaceSize ：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize 的值为20.75MB，这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置，新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值，建议将-XX:MetaspaceSize 设置为一个相对较高的值防止(高水位线多次调整,Full GC多次调用)。

方法区垃圾回收：常量池中废弃的常量（主要是字面量和符号引用）和不再使用的类型（类和接口的全限定名
字段的名称和描述符
方法的名称和描述符）。

HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收 判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法



3. 直接内存（非运行时数据区）
注：NIO类，直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。避免了在 Java 堆和 Native 堆之间来回复制数据。
- 私有
1. 程序计数器(JVM的字节码解释器改变计数器值来选取下一条执行的字节码指令。作用：代码流程控制；多线程时用于记录当前线程执行位置)

任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）

执行引擎运行的所有字节码指令只针对当前栈帧进行操作。Java 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出

![](/img/jvm/instruct.PNG)
JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。CPU切换线程需要知道从哪开始。
（分析：进入class文件所在目录，执行 javap -v xx.class 反解析（或者通过 IDEA 插件 Jclasslib 直接查看，上图），可以看到当前类对应的Code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。）

2. 虚拟机栈（每个线程在创建的时候都会创建一个虚拟机栈，由一个个栈帧组成，对应着一次次 Java 方法调用）

（1）作用：主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。

（2）特点：JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着入栈（进栈/压栈），方法执行结束出栈


（3）注： Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。

StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。

OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

（4）Java 栈可以类比数据结构中栈，Java栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。

栈帧：局部变量表（基本数据类型和对象引用（reference类型，可能指向对象起始地址或执行对象句柄）） 操作数栈 动态链接 方法返回地址 附加信息
![](/img/jvm/stack.PNG)

局部变量表：局部变量表最基本的存储单元是 Slot（变量槽），32 位以内的类型只占用一个 Slot(包括returnAddress类型)，64 位的类型（long和double）占用两个连续的 Slot，JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引可用其访问指定的局部变量值。槽位可重用

操作数栈：在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）。**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间**。

动态链接：指向运行时常量池中该栈帧所属方法的引用（每个栈帧内部）。
![](/img/jvm/link.PNG) 
在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**

在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关 静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接 动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接


方法返回地址：用来存放调用该方法的PC寄存器的值。无论通过哪种方式（执行完成或异常）退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。



3. 本地方法栈（为虚拟机使用到Native方法服务）
在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一

作用：有时 Java 应用需要与 Java 外面的环境交互。实现用 Java 与实现了 jre 的底层系统交互。Sun's Java,Sun的解释器就是C实现的，这使得它能像一些普通的C一样与外部交互。

## 内存模型（在线程栈和堆中划分）
#### JMM引入
- JMM与硬件内存结构关系（JMM如何与硬件内存模型配合使用）
 1. 硬件内存结构简介
![](/img/jvm/cpu.PNG)

2. 内存模型与硬件内存结构关系(**在硬件上，线程堆栈和堆都位于主存储器中。 线程堆栈和堆的一部分有时可能存在于CPU高速缓存和内部CPU寄存器中**)
![](/img/jvm/memory.PNG)

**JMM的存在，让我们不需要管局部变量和共享对象在堆还是栈中，他们都是存储在主存，每个线程（CPU上运行的线程）都可将其提取到单独CPU缓存中。**

JMM通过这种抽象成2层的概念, 既能提高程序的运行速度(保留了线程之间各自的缓存) , 也降低了开发者的开发难度 , 使得开发者在处理并发问题的时候, 不需要去考虑cpu与主内存之间五层缓存的复杂问题.

![](/img/jvm/sheap.PNG)

1. 内存模型与硬件内存两个问题

（1）对象共享可见性（如果两个或多个线程共享一个对象，而没有正确使用volatile声明或同步，则一个线程对共享对象的**更新可能对其他线程不可见**。线程AB将其读入不同CPU缓存，**cpu缓存未刷回主内存，更改版本对其他线程都不可见，每个线程都拥有自己的共享对象副本。**）

（2） 竞态条件（即同步问题，两个或多个线程共享一个对象，并且**多个线程更新该共享对象中的变量**，则可能会出现竞态。A,B将共享对象读入不同cpu缓存，再分别执行更新操作，变量增加两次但两次操作没有同步，无论线程A还是线程B将其写入主存储器，都是只进行了一次增量操作。可**使用Java synchronized块。 同步块保证在任何给定时间只有一个线程可以进入代码的给定关键部分。**同步块还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器，无论变量是不是声明为volatile）                           
        
#### 内存模型深入理解（定义了一套读写内存数据的规范）
（分为三部分：重排序与顺序一致性；**三个同步原语（lock，volatile，final）的内存语义，重排序规则及在处理器中的实现**；java 内存模型的设计，及其与处理器内存模型和顺序一致性内存模型的关系。）
  
- 并发编程两个问题（非JMM问题）：线程之间如何通信（什么机制来交换信息）及线程之间如何同步

1. 线程之间的通信机制有两种：

**（1）共享内存并发模型下，线程之间共享程序公共状态，通过读写公共状态通信**

（2）消息传递并发模型下，线程通过发送消息来通信

2. 线程同步：同步是指程序用于控制不同线程之间操作发生相对顺序的机制。**共享内存并发模型，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。**在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。

**Java 的并发采用的是共享内存模型**，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。

- Java 内存模型的抽象

**一是抽象了主内存和本地内存，二是控制了Java线程之间的通信**

JMM屏蔽了底层细节, **定义了一套读写内存数据的规范, 不再需要关心一级缓存二级缓存的问题,抽象了主内存和本地内存的概念(不在关注寄存器，缓存（CPU高速缓存，不是内存条），磁盘（主存RAM,是内存条和磁盘）)**.

本地内存并不是真的给每一个线程分配内存, 而是JMM的一个抽象, 是对于寄存器, 一级缓存, 二级缓存 三级缓存的抽象.

即下图中的这些缓存, 不用管独享的是哪一部分, 共享的是哪一部分. JMM帮我们抽象成了主内存和本地内存这两部分.
![](/img/jvm/cachec.PNG)



Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。  
线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。

**JMM涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。**

![](/img/jvm/jmm.PNG)

线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤： 

（1）首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。
（2）线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。

从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。
1.重排序与顺序一致性
 (1)重排序
执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。
从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：
![](/img/jvm/command.PNG)

这些重排序都可能会导致多线程程序出现内存可见性问题。 

## GC垃圾回收
#### GC回收基础
- 判断对象是否能被回收
1. 引用技术法（给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。故虚拟机不使用引用计数算法）
2. 可达性分析算法（GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收）
  
- 方法区回收
- 引用类型（判定对象是否可被回收都与引用有关）
1. 强引用（使用new创建，不会被回收）
2. 软引用（使用SoftReference类来创建，内存不够才被回收）
3. 弱引用（使用 WeakReference类创建，在下次垃圾回收一定会回收）
4. 虚引用（无法通过虚引用取得一个对象。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。）

- 垃圾收集算法
1. 标记-清除（存活对象标记，清除未标记对象）
不足：（1）标记清除效率不高
（2）产生大量不连续内存碎片，导致无法给大对象分配内存
2. 标记-整理（存活对象向一端移动，清理掉端边界以外的内存）
3. 复制（内存划分大小相等两块，每次只使用其中一块，一块内存用完将存活对象复制到另一块，再清除使用过的块）
不足：（1）只使用了内存一半

HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

- 分代收集
现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 
一般将堆分为新生代和老年代。 
（1）新生代使用: 复制算法 
（2）老年代使用: 标记 - 清除 或者 标记 - 整理 算法 

- 垃圾收集器
![](/img/jvm/GC.PNG)
以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

**单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程； 串行与并行: 串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。**

按线程数分：只有一个垃圾回收线程，成为串行垃圾回收器。有多个垃圾回收线程，称为并行垃圾回收器。
按工作模式分：并发式垃圾回收器与应用程序线程交替工作（尽可能减少应用程序停顿时间）。独占式垃圾回收器一旦运行，停止应用程序所有用户线程到垃圾回收结束。

- 新生代
1. Serial收集器
串行收集，单线程收集，优点简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。
![](/img/jvm/serial.PNG)
2. ParNew收集器
Serial 收集器的多线程版本。

 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。 默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。
![](/img/jvm/parnew.PNG)
3. Parallel Scavenge收集器（JDK8默认）
多线程收集器，目标是达到一个可控制的吞吐量(CPU用于运行用户代码的时间占总时间的比值)

高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

可以通过一个开关参数打开 GC 自适应的调节策略(GC Ergonomics)，就不需要手动指定新生代的大小(-Xmn)、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。
![]()

- 老年代
1. Serial Old收集器

 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途: 在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。
![](/img/jvm/serialo.PNG)
2. Parallel Old收集器（JDK8默认）
 Parallel Scavenge 收集器的老年代版本。
在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。
![](/img/jvm/parallelo.PNG)
3. CMS收集器（第一真正并发收集器）
CMS(Concurrent Mark Sweep)，Mark Sweep 指的是**标记 - 清除算法。**

 分为以下四个流程:  
 （1）初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 
 
 （2）并发标记: 进行 GC Roots Tracing （链路节点追踪）的过程，它在整个回收过程中耗时最长，**不需要停顿**。

 （3）重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 
 
 （4）并发清除: 不需要停顿。 
 
 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 
 
 具有以下缺点: 
 （1）吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 
 （2）无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 **CMS 收集不能像其它收集器那样等待老年代快满的时候再回收**。如果**预留的内存不够存放浮动垃圾**，就会出现 Concurrent Mode Failure，这时虚拟机将**临时启用 Serial Old 来替代 CMS**。
 （3） 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。
![](/img/jvm/cms.PNG)


-新生代/老年代
1. G1收集器（对新生代和老年代一起回收,JDK1.9默认回收器，在jdk1.7中正式使用的全新的垃圾收集器以替代CMS）
面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是**未来可以替换掉CMS收集器**。

整体采用标记-整理算法，局部是通过是通过复制算法，不会产生内存碎片

**G1的设计原则就是简化JVM性能调优**，开发人员只需要简单的三步即可完成调优：
第一步，开启G1垃圾收集器

第二步，设置堆的最大内存

第三步，设置最大的停顿时间

G1中提供了三种模式垃圾回收模式，Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。

原理：
G1垃圾收集器相对比其他收集器而言，最大的区别在于它**取消了年轻代、老年代的物理划分（无需再设置每个代），取而代之的是将堆划分为若干个区域（Region）**，（每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize=n可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。）这些区域中包含了有逻辑上的年轻代、老年代区域。
这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。G1最大的特点是引入分区的思路，弱化了分代的概念

G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。

G1将堆内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内存的回收是以region作为基本单位的；在每个分区内部又被分成了若干个大小为512 Byte卡片(Card)
![](/img/jvm/region.PNG)

标记-整理




--------------
垃圾回收的并发，并行

  - 并行：多条垃圾收集线程并行工作
  - 并发：用户线程与垃圾收集线程同时执行（同一时间段的并行）

  评估GC的性能指标（在最大吞吐量优先的情况下，降低停顿时间）

  - 吞吐量（运行用户代码的时间占总运行时间比例）
  - 暂停时间（执行垃圾收集时，程序的工作线程被暂停的时间）
  - 内存占用(Java堆区所占的内存大小)

  七款经典垃圾收集器

  垃圾收集器的组合

  ![](/img/jvm/垃圾收集器.PNG)

![](/img/jvm/垃圾收集器组合.PNG)

(1)Serial回收器：串行回收（在用户的桌面应用场景中，可用内存一般几十Mb-100多Mb，可在较短时间内完成垃圾收集，对于交互较强的应用，不能接收，一般Java web应用程序不会采用串行垃圾收集器）

(2)ParNew回收器：并行回收 

(3)Parallel Scavenge回收器：吞吐量优先（可控制吞吐量，即高效利用CPU时间完成任务，如执行批量处理，订单处理，工资支付等，吞吐量与STW相互制约，使用服务端）

(4)CMS回收器：低延迟（标清（不用标整，因为用户线程还在并发执行），缩短停顿时间，Java应用集中在互联网网站或B/S系统的服务端上）（四个环节）（缺点：碎片，若有大对象需分配，不得不提前触发Full GC/并发占用线程，吞吐量降低/无法处理浮动垃圾，即并发标记未标记的垃圾）（CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器（），它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作）

(5)G1回收器：区域分代化

- （针对配置多核CPU及大容量内存的机器，用于替换掉JDK1.5中的CMS收集器，相较于CMS，G1还未有压倒性优势，比如在用户程序运行的过程中，G1无论为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS高，大内存选G1，平衡点大概在6-8GB）
- （每次根据允许的收集时间，优先回收价值最大的**Region**（原有模式很难有突破，提出的分区Region概念，化整为零，叫做Humongous内存区域，用来存储大对象，超过1.5个region，就放到H），侧重点在与回收垃圾最大量的区间）
- （仍然属于分代型垃圾回收器，从堆的结构上看，它不要求整个Eden区、年轻代、老年代时连续的，它将堆空间分为若干个区域，这些区域中包含了逻辑上的年轻代和老年代，故该收集器同时兼顾年轻代和老年代）(在延迟可控情况下获得尽可能高的吞吐量，故称为全全功能收集器

![](/img/jvm/G1.PNG)

- G1垃圾回收过程主要包含三个环节：年轻代GC/老年代并发标记过程、混合回收（老年代old region对象过多，不是Old GC，除了回收整个Young Region，还会回收一部分Old Region）。还有个Full GC(但G1的初衷就是避免Full GC,一但需要调整（增大内存）)
- Remembered Set(任何收集器都是使用Remembered Set来避免全局扫描)/每个Region都有一个对应的RememberedSet(Region不可能孤立，其有可能被其他区外对象引用)


#### 内存分配与回收策略
- 内存分配策略
1. 对象优先在 Eden 分配
2. 大对象直接进入老年代
3. 长期存活的对象进入老年代
4. 动态对象年龄判定
5. 空间分配担保(发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的)  

Minor GC触发条件（当 Eden 空间满时，就将触发一次 Minor GC）
- Full GC触发条件
1. 调用 System.gc(让虚拟机执行 Full GC，不一定会执行)
2. 老年代空间不足( 可-Xmn 虚拟机参数调大新生代的大小-XX:MaxTenuringThreshold 调大对象进入老年代的年龄)
3. 空间分配担保失败
4.  Concurrent Mode Failure（执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)）


## 调试排错
#### 调优参数
- jvm参数
1. 堆： -Xms -Xmx  通常这两个配置参数相等，避免每次空间不足，动态扩容带来的影响。
2. 新生代：(1)-Xmn (2)-XX:NewRatio(新生代与老年代比值,设置了-Xmn的情况下，该参数是不需要在设置的，java 官方推荐配置为3:8) (3)-XX:MaxTenuringThreshold(新生代中对象存活次数，默认15) (4)-XX:SurvivorRatio(Eden区与Subrvivor区大小的比值)
3. 线程栈：-Xss 每个线程池的堆栈大小。在jdk5以上的版本，每个线程堆栈大小为1m，jdk5以前的版本是每个线程池大小为256k。
4. 老年代：-XX:PretenureSizeThreshold（对象超过多大值时直接在老年代中分配）
5. 代码：-XX:+AggressiveOpts(get,set 方法转成本地代码)  -XX:+AggressiveOpts(编译速度加快)

经验：（1）Xmn用于设置新生代的大小。过小会增加Minor GC频率，过大会减小老年代的大小。一般设为整个堆空间的1/4或1/3.
（2）XX:SurvivorRatio用于设置新生代中survivor空间(from/to)和eden空间的大小比例；XX:TargetSurvivorRatio表示，当经历Minor GC后，survivor空间占有量(百分比)超过它的时候，就会压缩进入老年代(即超过比例，对象不用达到最大年龄就进入老年代，当然，如果survivor空间不够，则直接进入老年代)。默认值为50%。
（3）将对象尽量留在新生代，老年代回收代价高
（4）Xms=Xmx，可以使得堆相对稳定，避免不停震荡
（5）一般来说，MaxPermSize设为64MB可以满足绝大多数的应用了。若依然出现方法区溢出，则可以设为128MB。若128MB还不能满足需求，那么就应该考虑程序优化了，减少动态类的产生。

- 垃圾回收
GC考虑指标：（1）吞吐量（2）停顿时间

1. 串行：-XX:+UseSerialGC
#### Java内存分析之堆内存和MetaSp ace内存

- Java 堆内存（Heap Memory)主要有两种形式的错误： 
1. OutOfMemoryError: Java heap space 

2. OutOfMemoryError: GC overhead limit exceeded 

- MetaSpace内存溢出

#### Java内存分析之堆外内存


##### PC寄存器常见问题

- PC寄存器存储字节码指令地址作用
- PC寄存器记录当前线程的执行地址：CPU运行时不断切换线程，切换回来需要知道当前线程从哪里开始执行

CPU时间片轮转，众多线程在并发执行过程中像是多个线程在并行

并行比较的时串行，并行与并发

垃圾回收线程一条串行，多条垃圾回收线程(用户线程需停止)并行，多条垃圾回收线程（用户线程不停止执行）并发

##### 虚拟机栈

栈是运行时的单位，堆是存储的单位

两种异常：

- StackOverflowError(如死递归（指针，快排有可能出现）)
- OutOfMemoryError

设置大小 -Xss1024k为Linux的默认（Idea VMoptions中设置）

class文件没有解析为二进制流文件，解析后是结构+操作指令等

栈帧中的动态链接：每一个栈帧内部包含一个指向运行时常量池中，该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。Java源文件被编译到字节码文件中时，所有的变量和方法引用都为符号引用保存再CLASS文件常量池中。

拥有动态链接后即拥有方法的jie

常量池运行起来后会将方法引用等信息存放到方法区中的运行时常量池

为什么需要常量池，为了提供一些符号和常量，便于指令的识别

方法调用其他方法在执行时将间件引用转换为直接引用（编译期确定为静态绑定，运行期确定为动态绑定）

调用非虚方法即编译期就能确定的

Java是静态类型语言，即判断变量类型自身信息，而不是变量值

执行引擎-》本地方法接口（Native Method Interface）->本地方法库(Native Method Libraries)

本地方法接口：native方法（一个JAVA调用非Java代码的接口）如Object类中的get Class（）/Thread类的start0(),Java层面的线程实际都需要转换成操作系统的本地线程

一个进程对应一个JVM实例，一个JVM实例中有一个运行时数据区（一个方法区一个堆，多个线程（多个程序计数器，本地方法栈，虚拟机栈）），

运行内存为虚拟内存，固态是物理内存，映射表将物理内存中不连续的地址到虚拟内存中形成逻辑上连续的地址

JVM规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的

新生代中伊甸园区和srrvivor区自适应的内存分配策略是默认关闭的，8:1:1

伊甸园区满了被回收，survivor中有放对象的是跟着被回收的

垃圾回收总结：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集

TLAB(堆是共享的，访问需要加锁，new对象是件麻烦的事情，为了提高效率，所以创建了TLAB，这个区域是线程独占的，无需考虑并发的问题分配对象就先分配到TLAB区域，满了或对象过大，就分配到TLAB外，这就要求我们创建对象时尽量创建小对象，提高效率)

代码优化之同步省略：JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程。锁对象也叫同步监视器，是否只能被一个线程访问，若是，则取消同步，这个取消同步的过程就叫同步省略，也叫锁消除

对象实例都是分配在堆上的，根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗，虽然经过逃逸分析可以做标量替换、栈上分析和锁消除，但逃逸分析自身也需要进行一系列复制分析，相对来说也是一个耗时的过程

如何解决OOM

静态引用对应的对象实体始终都存在堆空间 

直接内存是在Java堆外的，直接向系统申请的内存空间，来源于NIO，通过存在队中的DirectByteBuffer操作Native内存，通常，访问直接内存的速度优于Java堆，即读写性能高。Java的Nio库允许Java程序使用直接内存，用于数据缓冲区。

使用Nio时，操作系统划出的直接缓存可以被Java代码直接访问,只有一份，NIO适合对大文件的读写操纵。

### 执行引擎（既有编译器又有解释器）

没有执行引擎就没有谁能负责将字节码文件放到内存中，字节码文件中的字节码指令如何被JVM识别依赖于执行引擎

执行引擎的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。

JMM字节码经过Java虚拟机执行引擎中的JIT编译器最终变成机器指令（编译，全部编译为机器语言），当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行。（解释，逐行解释为机器语言）

执行引擎在去解释执行字节码文件让操作系统去执行的时候我们既可以使用解释器又可以使用编译器。（Java是半编译半解释语言的原因）

![](/img/jvm/半编译半解释.PNG)

高级语言-》汇编-》机器指令-》CPU

基于解释器执行已经沦落为低效的代名词。编译器将整个函数体编译成机器码，每次函数执行时，只执行编译后的机器码即可，还可将机器码缓存，下次获取不用编译。

热点数据触发JIT编译，方法调用计数器用于统计方法被调用的次数，在server模式下时10000次（安装的JVM默认为server）。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那么这个方法的调用及数据就会被减少一般。总的来说，只要系统运行的时间足够长，绝大部分方法都会被编译成本地代码。



### String不可变性

jdK9中String再也不用char[]存储，改成了byte[]加上编码标记，节约了空间

String中的String pool是一个固定大小的Hashtable，在JDK6中默认值大小是1009，如果池中的String太多，会造成Hash冲突严重，导致链表太长，造成string.intern时性能下降

- 常量与常量之间的拼接结果在常量池中，原理是编译期优化

- 常量与变量的拼接，只要拼接中有一个是变量，结果就在堆中，变量拼接的原理是StringBuilder（在JDK5.0之前使用的是Stringbuffer）

- intern()：判断字符串常量池中是否存在某个值，存在，返回常量池中的地址值，不存在，就在常量池中加载一份某个值，并返回

- 针对final修饰类、方法、基本数据类型，引用数据类型的量的结构时，能使用上final尽量使用上

  拼接操作与append()效率：

  - StringBuilder.append()只创建了一个StringBuilder对象，String做字符串拼接操作时，创建过多个StringBuilder和String对象
  - 字符串拼接的方式，创建的对象过多，占用的内存太大

  改进：StringBuilder底层使用的是数组，默认长度为16，数组满后会进行扩容复 制的操作，如果在初始化时就指定了固定的长度，就可以提高效率

  intern()的使用：如果不是用双引号声明的String对象，可以使用String提供的intern方法确认字符串是否存在， 存在则返回字符串常量池中的地址，若不存在会创建一个引用（该地址（不是堆中对象的地址）指指向堆中的对象，JDK8）放入串池，并返回串池中的引用地址。通过new StringBuilder（“xx”）.toString()并不会在字符串常量池中生成“xx，其转化为String对象的API是new String(value, 0, count)，不是new String (char[]);

  JDK6/7/8在处理常量之间拼接的不同

  如果s3.intern()作用成功，就在字符串常量池中生成”xx“，

  - jdk6创建了一个新的对象”xx“（串池中没有将对象复制一份，放入串池，并返回串池中的对象地址）
  - jdk7/8字符串常量池被移到堆中，堆中已经有对象"XX",不需要在字符串常量池中再新建（串池中没有，把对象的引用地址复制一份，放入串池，并返回串池中的引用 地址）
  - s4使用其字符串，则说明s4使用的是s3常量池的地址，s3==s4
  - s.intern创建引用后，为什么s==”aa“  

  G1垃圾回收器的去重操作（堆存活数据集合里面 string对象占了25%，重复String对象有13.5%，堆上重复的String对象应该是一种内存浪费）

  ### 垃圾回收

  垃圾指运行程序中没有任何指针指向的对象

  垃圾回收简介：

  （1）标记

  - 引用计数算法
  - 可达性分析算法（收集的对象：虚拟机中引用的对象、本地方法栈内JNI引用的对象、方法区中类静态属性引用的对象、所有被同步锁synchronized持有的对象、Java虚拟机内部的引用）-》涉及重写finalize()，不可达的对象并非非死不可
  - MAT相较于Jvisualm查看GC root更方便，是一款内存分析器/性能分析工具

  （2）清除

  新的垃圾回收器更关注低延迟

  

  ### 垃圾回收的相关概念

  （1）

  - System.gc()可以主动调用GC（提醒虚拟机显式触发Full GC，且会先调用Minor GC?）
  - System.runFinalization(强制调用使用引用的对象的finalize方法 )

  （2）内存溢出与内存泄漏

  - 泄漏：单例模式（在单例模式中，如果持有对外部对象的引用，那么这个外部对象就不能被回收）/资源未close(数据库，socket,io)

  （3）stw事件理解（GC事件发生时，应用程序会停顿）

  (4)垃圾回收的并发与并行 

  （5）安全点(程序不是任何时候都能执行GC)与安全区域(在区域内线程sleep唤醒后需完成GC才能离开)

  - Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的safepoint

  （6）引用类型（强引：不回收/软引：内存不足即回收/弱引：发现即回收/虚引：对象回收跟踪）

  - 强引用时造成Java内存泄漏的主要原因之一
  - 软引通常用来实现内存敏感的缓存 
  - 在weakHashmap中就使用到了弱引用，相较于hashmap其存储数据在内存不足时会回收
  - 虚引用必须和引用队列一起使用，创建时必须提供一个引用队列作为参数，即被虚引用引用的对象被回收时，将虚引用加入引用队列，以通知应用程序对象的回收情况

  ### 垃圾收集器

  垃圾回收的并发，并行

  - 并行：多条垃圾收集线程并行工作
  - 并发：用户线程与垃圾收集线程同时执行（同一时间段的并行）

  评估GC的性能指标（在最大吞吐量优先的情况下，降低停顿时间）

  - 吞吐量（运行用户代码的时间占总运行时间比例）
  - 暂停时间（执行垃圾收集时，程序的工作线程被暂停的时间）
  - 内存占用(Java堆区所占的内存大小)

  七款经典垃圾收集器

  垃圾收集器的组合

  ![](/img/jvm/垃圾收集器.PNG)

![](/img/jvm/垃圾收集器组合.PNG)

(1)Serial回收器：串行回收（在用户的桌面应用场景中，可用内存一般几十Mb-100多Mb，可在较短时间内完成垃圾收集，对于交互较强的应用，不能接收，一般Java web应用程序不会采用串行垃圾收集器）

(2)ParNew回收器：并行回收 

(3)Parallel Scavenge回收器：吞吐量优先（可控制吞吐量，即高效利用CPU时间完成任务，如执行批量处理，订单处理，工资支付等，吞吐量与STW相互制约，使用服务端）

(4)CMS回收器：低延迟（标清（不用标整，因为用户线程还在并发执行），缩短停顿时间，Java应用集中在互联网网站或B/S系统的服务端上）（四个环节）（缺点：碎片，若有大对象需分配，不得不提前触发Full GC/并发占用线程，吞吐量降低/无法处理浮动垃圾，即并发标记未标记的垃圾）（CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器（），它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作）

(5)G1回收器：区域分代化

- （针对配置多核CPU及大容量内存的机器，用于替换掉JDK1.5中的CMS收集器，相较于CMS，G1还未有压倒性优势，比如在用户程序运行的过程中，G1无论为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS高，大内存选G1，平衡点大概在6-8GB）
- （每次根据允许的收集时间，优先回收价值最大的**Region**（原有模式很难有突破，提出的分区Region概念，化整为零，叫做Humongous内存区域，用来存储大对象，超过1.5个region，就放到H），侧重点在与回收垃圾最大量的区间）
- （仍然属于分代型垃圾回收器，从堆的结构上看，它不要求整个Eden区、年轻代、老年代时连续的，它将堆空间分为若干个区域，这些区域中包含了逻辑上的年轻代和老年代，故该收集器同时兼顾年轻代和老年代）(在延迟可控情况下获得尽可能高的吞吐量，故称为全全功能收集器

![](/img/jvm/G1.PNG)

- G1垃圾回收过程主要包含三个环节：年轻代GC/老年代并发标记过程、混合回收（老年代old region对象过多，不是Old GC，除了回收整个Young Region，还会回收一部分Old Region）。还有个Full GC(但G1的初衷就是避免Full GC,一但需要调整（增大内存）)
- Remembered Set(任何收集器都是使用Remembered Set来避免全局扫描)/每个Region都有一个对应的RememberedSet(Region不可能孤立，其有可能被其他区外对象引用)



### 字节码文件

![](/img/jvm/JVM路线.PNG)

父子类输出变量（涉及显示初始化>构造器初始化）,Father son=new Son()，子类构造器与父类构造器调用一个方法x()，在实例化时调用的是子类的方法，方法中涉及的变量也是子类中未显示初始化的变量，son.属性调用的是父类的属性（属性不存在多态性）

class文件是以8位二进制流为基础，通过软件转化为易识别的16进制文件，涉及的是计算机通过识别不同的二进制码来执行不同的操作，*ASCII*码就是将*机器码*翻译成人类可以识别的编码（如一串二进制码转化为java/xx/xx）

方法所属的类，方法名称、参数、返回值类型

JDK解析class字节码文件其实就是标识为01的字符串过程（即最终指向字面量）

当真正进行类的加载，形成动态链接的时候(找到真正的内存入口地址)，此时才转化为直接引用

LineNumberTable刻画的就是字节码指令与代码之间的对应关系

JVM调优分为GC调优和代码层面调优

java -g xx.java(加-g 生成对应的局部变量表信息，IDEA等工具默认编译时有加上局部变量表信息)

![](/img/jvm/javap.PNG)

 常用-s/-l/-c/-v -verbose 

#### 字节码指令集与解析举例 

Java虚拟机的指令由一个字节长度的代表则会某种特定操作含义的数字以及跟随其后的零至多个代表次操作所需参数而构成。意味着指令集的操作码总数不可能超过256条。*aload_0* = 42 (0x2a)

###### 加载与存储指令概述

作用：加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递

操作数栈：存放计算的操作数以及返回结果（执行每条指令之前，JAVA虚拟机要求该指令的操作数已经被压入操作数栈中，执行指令时，java虚拟机会将指令所需的操作数弹出，并且将指令的结果重新压入栈中）

局部变量表(数组)：字节码程序可以将计算的结果缓存在局部变量去之中（依次存放this指针(仅非静态方法)、所传入参数/字节码中的局部变量）

##### 局部变量表压栈指令

![](/img/jvm/压栈指令.PNG)

 常量入栈指令

![](/img/jvm/常量入栈指令.PNG)

![](/img/jvm/常量入栈指令1.PNG)

long/double占两个slot槽位

##### 出栈装入栈局部变量表指令

![](/img/jvm/出栈装入栈局部变量表指令1.PNG)

![](/img/jvm/出栈装入栈局部变量指令表2.PNG)

##### 算数指令

![](/img/jvm/算数指令.PNG)

底层涉及i=i+10，与i+=10前一个分为从局部变量表中取出数据在放到操作数栈中进行相加，最后再放到局部变量表中，后一个只需再局部变量表中就能完成相加操作(一个指令就能完成)

声明完变量，初始值放入插槽就会出栈，做运算前是空栈

面试题(先++与后++)：其字节码操作指令完全一致，若涉及到与其他运算符一起计算的场景，

![](/img/jvm/++i与i++PNG.PNG)

区别在于入栈指令在自增之前执行还是之后执行

![](/img/jvm/自增覆盖问题.PNG)

##### 比较指令

比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈。

比较指令有：dcmpg,dcmpl,fcmpg,fcmpl,lcmp

04类型转换指令（主要是针对8种基本数据类型，分为宽化与窄化 ）

宽化（简化为int->long->float->double，如i2l,i2f）

会存在精度损失问题，不会抛出运行时异常

byte,short,char在内存中都看成int来处理，即没有转换时没有操作指令

窄化()

窄化中存在int转byte,short,char指令 

05对象的创建与访问指令

创建对象时通过字节码指令，与类的加载对比分析（执行该字节码指令是否属于初始化）

### 类的加载过程详解

初始化后会在方法区存放类的模板，然后就可以使用，通过调用该类的静态方法或实例化创建类的对象

类将.class文件文件加载至元空间后，在堆中创建一个class对象，用来封装类位于方法区内的数据结构，该class对象时在加载类的过程中创建的，每个类都有对应有一个CLAss类型的对象

到初始化时n

，涉及到的都是类的初始化，不涉及到非静态变量

static final通过使用new赋值，并不会在属性字段处生成引用，而是在method中clint方法中通过字节码操作指令生成对应的字段

通过解析操作，符号引用节可以转变为目标方法在类中方法表的位置，从而使得方法成功调用

类初始化阶段的重要工作时执行类的初始化方法clint方法（该方法由Java编译器生成由JVM调用，它是由类静态成员的赋值语句以及static语句块合并而成的）

在初始化阶段,jvm调用初始化方法为类变量赋值

字段哪种场景下才有clint方法（类中需有static字段且显示赋值(非调用方法的final static也有)）

final+static在链接的准备阶段赋值的情况

- 对于基本数据类型的字段来说，显示赋值（直接赋值常量，而非调用方法）
- 对于String来说，如果使用字面量方式赋值

可总结为显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显示赋值，是在链接阶段的准备环节进行的

clint方法的线程安全性：虚拟机会保证一个类的clint方法在多线程环境下被正确的加锁同步，如果多个线程同时去初始化一个类，那么只有一个线程会去执行这个类的clint方法，其他线程都需要阻塞等待，直到活动线程执行clint方法

Java程序对类的使用分为两种，主动使用（才会使用clint）与被动使用，class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型（并不是在代码中出现的类，就一定会被初始化，如果不符合主动使用的条件，类就不会初始化）

首次调用需要主动使用(调用clint)，后面程序员使用无需再clint（我的理解是调用static方法属性（调用方法的）则会调用clint方法，跟Init构造器方法无关，只是对静态属性方法赋值，给调用的类使用），其只执行一次

基本数据类型由虚拟机预先定义，引用数据类型需要进行类的加载

##### 类的卸载

![](/img/jvm/类加载器关联.PNG)

#### JVM调优

为什么要调优：防止出现OOM、解决OOM、减少Full GC出现的频率

**性能优化的步骤**：

- 性能监控（发现问题----GC频繁、cpu load过高、OOM、内存泄漏、死锁、程序响应时间过长）
- 性能分析（排查问题-----GC日志、命令行、监控工具、jstack查看堆栈）
- 性能调优（解决问题-----增加内存，选择合适的回收器、优化代码、增加机器、合理的线程数、使用中间件，缓存，消息队列等、其他）

调优指标：停顿时间（或响应时间）、吞吐量、并发数、内存占用、相互间关系

命令行篇：

(1)jps查看正在运行的Java进程（-l全类名 -m主程序传参 -v进程JVM参数）

(2)jstat查看JVM统计信息(常用于检测垃圾回收与内存泄漏问题，没有GUI时是运行期定位虚拟机性能问题的首选工具)

- -class xxid显示类加载、卸载、耗时 (类相关)

  jstat -class -t  -h表头次数 进程号 -时间 -次数

- 垃圾回收相关(重点)

  挖掘信息（jstat -gc -t  xxid 间隔 次数）（如打印10次的时间，与GC间隔时间，如果GC总时间占比超过20%说明堆的压力有点大，如果超过90%说明堆里几乎没有可用空间，随时都可能抛出OOM异常）

  （判断内存泄漏）（jstat -gc -t  xxid 间隔 次数）（如多次命令，随机抽取其中OU的最小值，如果这些值呈现出上涨趋势，说明程序的老年代内存已使用量在不断上涨，可能存在内存泄漏）

- JIT相关

  -compiler显示JIT编译信息

  -printcompilation编译过的方法

（3）jinfo（查看虚拟机配置参数信息，可用于调整虚拟机的配置参数（运行时可修改））

（4）jmap（导出内存映像文件&内存使用情况）

（5）jhat（（JDK自带堆分析工具，JDK9,10被替代）内置了HTTP/HTML服务器，生成dump文件的分析结果，用户可在浏览器中查看分析结果）

（6）jstack打印JVM中线程快照

（7）jcmd（多功能命令行，建议替换jmap）

### 开发工具

开发中常用

(1)Visual VM

远程：可调用远程服务的JAVA进程去监控其他服务器的服务性能(ip,jmx该文件，将服务器地址变为公网地址，防火墙等等)

场景：运维通过JMP生成dump传给我，可以使用Visual vm读取装入

主要功能：生成/读取堆内存快照--查好看JVM参数、系统属性--查看运行虚拟机进程--生成、读取线程快照--实时监控--其他功能

MAT用于发现内存泄漏问题（重点在于获取堆dump文件和分析堆dump文件）(为开发人员生成内存泄漏报表)

- histogram（实例数目、实例信息等）
- thread overview（java线程、局部变量信息）
- 

建议选择vm+阿尔萨斯+jp

第三章是调优的精华

追求机制性能的场景下，了解你的程序运行中cpu在干什么，火焰图就是一种非常直观的展示cpu在程序整个声明周期过程中时间分配的工具，如果你想改善接口，提高极致的性能，就可以选择火焰图





在JDK6后默认开启了逃逸分析和标量替换

xms与xmx设置未fullgc后老年代内存占用3-4倍，元空间设置为老年代存活对象（都是FULLGC后）的1.2-1.5，年轻代xmn为老年代存活对象1-1.5

